<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Super 8 - Beach Tennis</title>
<style>
    /* Reset básico e box-sizing para melhor responsividade */
    html {
        box-sizing: border-box;
    }
    *, *::before, *::after {
        box-sizing: inherit;
    }

    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      margin: 0; padding: 0; background: #f0f2f5; color: #333;
      display: flex;
      flex-direction: column; /* Organiza itens em coluna */
      min-height: 100vh; /* Garante que o body ocupe a altura total da tela */
    }
    header {
      background: #2980b9; color: white; padding: 1rem; text-align: center;
      font-weight: 700; font-size: 1.4rem;
    }
    main {
      max-width: 900px; /* Largura máxima fixa para evitar redimensionamento */
      width: 100%; /* Garante que ocupe a largura total dentro do max-width */
      margin: 1rem auto; /* Centraliza o main */
      background: white; border-radius: 8px; box-shadow: 0 0 10px rgb(0 0 0 / 0.1);
      padding: 1rem 2rem 2rem 2rem;
      flex-grow: 1; /* Garante que o main ocupe o espaço restante */
    }
    nav {
      display: flex; border-bottom: 2px solid #2980b9; margin-bottom: 1rem;
    }
    nav button {
      flex: 1; background: transparent; border: none; padding: 1rem; font-size: 1rem; cursor: pointer; font-weight: 600; color: #2980b9;
      border-bottom: 3px solid transparent; transition: 0.3s ease;
    }
    nav button.active {
      border-bottom-color: #2980b9; color: #145a86;
    }
    section {
      display: none;
    }
    section.active {
      display: block;
    }
    label {
      display: block; margin-top: 0.8rem; font-weight: 600;
    }
    textarea, input[type=text] {
      width: 100%; padding: 8px; margin-top: 0.3rem; border-radius: 4px; border: 1px solid #ccc; font-size: 1rem;
    }
    textarea {
      resize: vertical;
    }
    fieldset {
      border: 1px solid #ccc; border-radius: 5px; padding: 10px 15px 15px 15px; margin-top: 1rem;
    }
    legend {
      font-weight: 700; color: #2980b9; padding: 0 6px;
    }
    button.action-btn {
      background: #2980b9; color: white; border: none; padding: 10px 20px; margin-top: 15px; border-radius: 5px; cursor: pointer;
      font-weight: 700; margin-right: 10px; /* Espaço entre botões */
    }
    button.action-btn:hover {
      background: #1c5d86;
    }
    button.action-btn:disabled {
        background: #cccccc;
        cursor: not-allowed;
    }
    table {
      width: 100%; border-collapse: collapse; margin-top: 1rem;
    }
    th, td {
      border: 1px solid #ddd; padding: 8px; text-align: center;
    }
    th {
      background: #2980b9; color: white;
    }
    /* Novos estilos para estreitar as colunas de Rodada e Quadra */
    .col-rodada {
        width: 10%; /* Ajuste conforme necessário */
        min-width: 60px; /* Garante um tamanho mínimo */
    }
    .col-quadra {
        width: 10%; /* Ajuste conforme necessário */
        min-width: 60px; /* Garante um tamanho mínimo */
    }

    input.result-input {
      width: 50px; text-align: center; font-weight: 600; font-size: 1rem; border: 1px solid #2980b9; border-radius: 4px;
    }
    .center {
      text-align: center;
    }
    .player-highlight {
        font-weight: bold;
        color: red;
        font-size: 1.1rem;
    }
    .option-buttons {
        margin-top: 15px;
        display: flex;
        gap: 10px;
    }
    #quadrasInputContainer {
        margin-top: 15px;
    }
    #quadrasInputContainer label {
        display: inline-block; /* Para manter o label e o input na mesma linha */
        margin-right: 10px;
    }
    #quadras {
        width: auto; /* Ajusta a largura para caber o número */
        padding: 5px;
        text-align: center;
    }

    footer {
        text-align: center;
        padding: 1rem;
        background: #2980b9;
        color: white;
        margin-top: auto; /* Empurra o rodapé para baixo */
    }
    .footer-text {
        margin: 0.2rem 0; /* Espaçamento para o texto do rodapé */
        font-size: 0.9em;
    }

    .criteria-text {
        margin-top: 1rem;
        font-size: 0.9em;
        color: #555;
    }
    .criteria-list {
        margin-left: 1.5rem;
        padding-left: 0;
    }

    /* Estilos para o Fieldset de Modo de Jogo */
    fieldset:has(input[name="modo"]) {
        display: flex;
        flex-wrap: wrap; /* Permite que os itens quebrem para a próxima linha */
        gap: 10px; /* Espaço entre os itens */
        justify-content: space-between; /* Distribui os itens horizontalmente */
        align-items: center; /* Centraliza verticalmente */
    }

    fieldset:has(input[name="modo"]) label {
        display: flex; /* Para alinhar o rádio e o texto */
        align-items: center;
        margin-top: 0; /* Remove margem superior padrão */
        font-weight: normal; /* Normaliza o peso da fonte */
        flex-basis: calc(50% - 5px); /* Duas colunas por padrão */
    }

    fieldset:has(input[name="modo"]) input[type="radio"] {
        margin-right: 5px; /* Espaço entre o rádio e o texto */
    }


    /* Media Queries para responsividade */
    @media (max-width: 768px) { /* Tablets e telas menores */
        main {
            padding: 1rem 1.5rem; /* Ajusta padding para telas um pouco menores */
        }
        nav button {
            font-size: 0.9rem;
            padding: 0.8rem;
        }
        fieldset:has(input[name="modo"]) label {
            flex-basis: 100%; /* Uma coluna em telas menores */
        }
    }

    @media (max-width: 600px) { /* Smartphones */
        main {
            margin: 0.5rem auto;
            padding: 1rem; /* Mais ajuste de padding para telas pequenas */
        }
        header {
            font-size: 1.2rem;
            padding: 0.8rem;
        }
        nav button {
            font-size: 0.8rem;
            padding: 0.6rem;
        }
        table, th, td {
            font-size: 0.75rem; /* Reduz a fonte da tabela */
            padding: 6px;
        }
        input.result-input {
            width: 40px; /* Reduz largura dos inputs de resultado */
            font-size: 0.8rem;
        }
        button.action-btn {
            padding: 8px 15px;
            font-size: 0.9rem;
        }
        /* Ajuste para que o texto do label não quebre tão cedo no modo de jogo */
        fieldset:has(input[name="modo"]) label {
             font-size: 0.9rem; /* Reduz a fonte do texto do rádio */
        }
    }
</style>
</head>
<body>

<header>Super 8 - Beach Tennis</header>

<main>
    <nav>
        <button class="tab-button active" data-tab="config">Configuração</button>
        <button class="tab-button" data-tab="jogos">Jogos</button>
        <button class="tab-button" data-tab="resultado">Resultado</button>
    </nav>

    <section id="config" class="active">
        <fieldset>
            <legend>Modo de Jogo</legend>
            <label><input type="radio" name="modo" value="individual-sem-pote" checked> Individual sem pote</label>
            <label><input type="radio" name="modo" value="individual-com-pote"> Individual com pote</label>
            <label><input type="radio" name="modo" value="dupla-fixa-sem-pote"> Dupla fixa sem pote</label>
            <label><input type="radio" name="modo" value="dupla-fixa-com-pote"> Dupla fixa com pote</label>
        </fieldset>

        <div id="campoSemPote">
            <label for="jogadores">Jogadores (um por linha):</label>
            <textarea id="jogadores" rows="8" placeholder="Exemplo: Lucas&#10;Maria&#10;Pedro&#10;Ana"></textarea>
        </div>

        <div id="campoComPote" style="display:none;">
            <label for="pote1">Pote 1 (um por linha):</label>
            <textarea id="pote1" rows="6" placeholder="Exemplo: Lucas&#10;Pedro&#10;João&#10;Paulo"></textarea>

            <label for="pote2">Pote 2 (um por linha):</label>
            <textarea id="pote2" rows="6" placeholder="Exemplo: Maria&#10;Ana&#10;Carla&#10;Marina"></textarea>
            <div id="poteOptions" style="display:none;">
                <p>Os potes têm números de jogadores diferentes. Escolha uma opção:</p>
                <div class="option-buttons">
                    <button class="action-btn" id="btnExcludePlayer">Excluir um jogador do pote maior</button>
                    <button class="action-btn" id="btnMovePlayer" style="display:none;">Mover um jogador para o outro pote</button>
                </div>
                <div id="playerActionInfo" class="player-highlight" style="display:none;"></div>
            </div>
        </div>
        
        <div id="quadrasInputContainer">
            <label for="quadras">Quantidade de Quadras:</label>
            <input type="number" id="quadras" value="1" min="1">
            <span id="quadrasInfo" style="font-size: 0.9em; color: #555;"></span>
        </div>

        <button class="action-btn" id="btnSortear">Sortear Jogos</button>
        <button class="action-btn" id="btnReiniciar">Reiniciar</button>
    </section>

    <section id="jogos">
        <table id="tabelaJogos">
            <thead>
                <tr>
                    <th class="col-rodada">Rodada</th>
                    <th class="col-quadra">Quadra</th>
                    <th>Dupla A</th>
                    <th>Resultado (Games)</th> 
                    <th>Dupla B</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
    </section>

    <section id="resultado">
        <table id="tabelaResultado">
            <thead>
                <tr>
                    <th>Posição</th>
                    <th id="headerName">Jogador</th> 
                    <th>Vitórias</th>
                    <th>Derrotas</th>
                    <th>Saldo de Games</th> 
                    <th>Games Ganhados</th>
                    <th>Games Perdidos</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
        <p class="criteria-text">
            **Critérios de Desempate:**
            <ol class="criteria-list">
                <li>Maior número de **Vitórias**</li>
                <li>Maior **Saldo de Games** (Games Ganhados - Games Perdidos)</li>
                <li>Em caso de novo empate, o critério é o **Confronto Direto** (quem ganhou o jogo entre os empatados)</li>
            </ol>
        </p>
    </section>
</main>

<footer>
    <div class="footer-text">© 2025 Todos os direitos reservados. Proibida a cópia ou reprodução.</div>
    <div class="footer-text">Desenvolvido por Lauro Licce.</div>
    <div class="footer-text">v1.0.0</div> </footer>

<script>
    // Gerenciamento de abas
    const tabButtons = document.querySelectorAll('.tab-button');
    const sections = document.querySelectorAll('main section');

    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            const targetTab = button.dataset.tab;
            sections.forEach(section => {
                if (section.id === targetTab) section.classList.add('active');
                else section.classList.remove('active');
            });
            // Quando muda para a aba de resultado, atualiza a classificação e mostra o pop-up do campeão
            if (targetTab === 'resultado') {
                updateClassification(true); // true para indicar que é uma atualização de tab
            }
        });
    });

    // Referências a elementos DOM
    const radiosModo = document.querySelectorAll('input[name="modo"]');
    const campoSemPote = document.getElementById('campoSemPote');
    const campoComPote = document.getElementById('campoComPote');
    const poteOptionsDiv = document.getElementById('poteOptions');
    const playerActionInfoDiv = document.getElementById('playerActionInfo');
    const btnMovePlayer = document.getElementById('btnMovePlayer');
    const jogadoresTextArea = document.getElementById('jogadores');
    const pote1TextArea = document.getElementById('pote1');
    const pote2TextArea = document.getElementById('pote2');
    const tabelaJogosBody = document.querySelector('#tabelaJogos tbody');
    const tabelaResultadoBody = document.querySelector('#tabelaResultado tbody');
    const headerName = document.getElementById('headerName'); // Cabeçalho dinâmico
    const quadrasInput = document.getElementById('quadras');
    const quadrasInfoSpan = document.getElementById('quadrasInfo');
    const btnSortear = document.getElementById('btnSortear');
    const btnReiniciar = document.getElementById('btnReiniciar');

    // Estado global da aplicação
    let generatedGames = [];
    let currentMode = 'individual-sem-pote'; // Modo de jogo inicial
    let fixedDuosMap = {}; // Armazenará as duplas fixas para o torneio

    // Constantes para chaves do localStorage
    const LOCAL_STORAGE_KEY_GAMES = 'super8_generatedGames';
    const LOCAL_STORAGE_KEY_CONFIG = 'super8_config';
    const LOCAL_STORAGE_KEY_MODE_LOCKED = 'super8_modeLocked';
    const LOCAL_STORAGE_KEY_FIXED_DUOS = 'super8_fixedDuos'; // Nova chave para duplas fixas

    // Event listener para mudança de modo de jogo
    radiosModo.forEach(radio => radio.addEventListener('change', () => {
        currentMode = radio.value;
        if (currentMode.includes('com-pote')) {
            campoComPote.style.display = 'block';
            campoSemPote.style.display = 'none';
        } else {
            campoComPote.style.display = 'none';
            campoSemPote.style.display = 'block';
        }
        // Limpa opções de pote e informações de jogador ao mudar o modo
        poteOptionsDiv.style.display = 'none';
        playerActionInfoDiv.style.display = 'none';
        // Não reseta o localStorage aqui, apenas ao clicar em "Reiniciar"
        updateQuadrasInputLimits(); // Atualiza limites de quadras ao mudar o modo/jogadores
    }));

    // Event listener para input de jogadores/potes para atualizar limites de quadra
    jogadoresTextArea.addEventListener('input', updateQuadrasInputLimits);
    pote1TextArea.addEventListener('input', updateQuadrasInputLimits);
    pote2TextArea.addEventListener('input', updateQuadrasInputLimits);

    /**
     * Exibe um alerta simples (substituindo o pop-up).
     * @param {string} message - A mensagem a ser exibida.
     */
    function showAlert(message) {
        alert(message);
    }

    /**
     * Salva o estado atual do jogo no localStorage.
     */
    function saveGameState() {
        const config = {
            mode: currentMode,
            jogadores: jogadoresTextArea.value,
            pote1: pote1TextArea.value,
            pote2: pote2TextArea.value,
            quadras: quadrasInput.value
        };
        localStorage.setItem(LOCAL_STORAGE_KEY_GAMES, JSON.stringify(generatedGames));
        localStorage.setItem(LOCAL_STORAGE_KEY_CONFIG, JSON.stringify(config));
        localStorage.setItem(LOCAL_STORAGE_KEY_FIXED_DUOS, JSON.stringify(fixedDuosMap));

        if (generatedGames.length > 0) {
            localStorage.setItem(LOCAL_STORAGE_KEY_MODE_LOCKED, 'true');
        } else {
            localStorage.removeItem(LOCAL_STORAGE_KEY_MODE_LOCKED);
        }
    }

    /**
     * Carrega o estado do jogo do localStorage.
     */
    function loadGameState() {
        const savedGames = localStorage.getItem(LOCAL_STORAGE_KEY_GAMES);
        const savedConfig = localStorage.getItem(LOCAL_STORAGE_KEY_CONFIG);
        const modeLocked = localStorage.getItem(LOCAL_STORAGE_KEY_MODE_LOCKED) === 'true';
        const savedFixedDuos = localStorage.getItem(LOCAL_STORAGE_KEY_FIXED_DUOS);

        if (savedConfig) {
            const config = JSON.parse(savedConfig);
            currentMode = config.mode;
            
            document.querySelector(`input[name="modo"][value="${currentMode}"]`).checked = true;

            if (currentMode.includes('com-pote')) {
                campoComPote.style.display = 'block';
                campoSemPote.style.display = 'none';
            } else {
                campoComPote.style.display = 'none';
                campoSemPote.style.display = 'block';
            }

            // Removendo nomes genéricos e deixando vazios se não houver config salva
            jogadoresTextArea.value = config.jogadores || '';
            pote1TextArea.value = config.pote1 || '';
            pote2TextArea.value = config.pote2 || '';
            quadrasInput.value = config.quadras || 1;
        } else {
            // Se não há config salva, reseta para o estado inicial padrão (campos vazios)
            resetApplicationState(false); 
        }

        if (savedFixedDuos) {
            fixedDuosMap = JSON.parse(savedFixedDuos);
        }

        if (savedGames) {
            generatedGames = JSON.parse(savedGames);
            displayGames(generatedGames);
            updateClassification(); // Não mostra pop-up de campeão no load inicial
            tabButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector('button[data-tab="jogos"]').classList.add('active');
            sections.forEach(sec => {
                if (sec.id === 'jogos') sec.classList.add('active');
                else sec.classList.remove('active');
            });
            // Habilita/desabilita campos de texto e botão de sortear
            setConfigurationFieldsDisabled(true); 
            // Os rádios de modo são desabilitados APENAS se o modo está "travado"
            radiosModo.forEach(radio => radio.disabled = modeLocked);

        } else {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector('button[data-tab="config"]').classList.add('active');
            sections.forEach(sec => {
                if (sec.id === 'config') sec.classList.add('active');
                else sec.classList.remove('active');
            });
            setConfigurationFieldsDisabled(false);
            // Garante que os radios estejam habilitados se não há jogos salvos
            radiosModo.forEach(radio => radio.disabled = false);
        }
        updateQuadrasInputLimits(); 
    }

    /**
     * Embaralha um array (Fisher-Yates shuffle).
     * @param {Array} array - O array a ser embaralhado.
     */
    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    /**
     * Normaliza a entrada de texto de jogadores/potes para um array limpo de strings.
     * Remove espaços em branco extras e linhas vazias.
     * @param {string} text - O texto de entrada do textarea.
     * @returns {Array<string>} Um array de nomes de jogadores.
     */
    function parsePlayerInput(text) {
        return text.split('\n')
                   .map(player => player.trim())
                   .filter(player => player !== '');
    }

    /**
     * Calcula o número máximo de quadras com base no número de jogadores.
     * 1 quadra para cada 4 jogadores (ou 2 duplas), arredondado para baixo.
     * @param {number} numPlayers - O número total de jogadores.
     * @param {string} mode - O modo de jogo ('individual' ou 'dupla').
     * @returns {number} O número máximo de quadras.
     */
    function calculateMaxQuadras(numPlayers, mode) {
        if (mode === 'dupla') {
            return Math.floor(numPlayers / 2); // Cada 2 duplas (4 jogadores) podem jogar em 1 quadra
        } else { // Individual
            return Math.floor(numPlayers / 4); // Cada 4 jogadores formam um jogo, usando 1 quadra
        }
    }

    /**
     * Atualiza os limites (min/max) do input de quadras e exibe uma mensagem.
     */
    function updateQuadrasInputLimits() {
        let playersCount = 0;
        let modeForCalculation = 'individual'; 

        if (currentMode.includes('com-pote')) {
            const pote1 = parsePlayerInput(pote1TextArea.value);
            const pote2 = parsePlayerInput(pote2TextArea.value);
            
            if (currentMode.startsWith('dupla-fixa')) {
                modeForCalculation = 'dupla';
                playersCount = Math.min(pote1.length, pote2.length); 
            } else { // individual-com-pote
                playersCount = pote1.length + pote2.length;
            }
        } else {
            const players = parsePlayerInput(jogadoresTextArea.value);
            playersCount = players.length;
            if (currentMode.startsWith('dupla-fixa')) {
                modeForCalculation = 'dupla';
                playersCount = Math.ceil(players.length / 2); 
            }
        }
        
        const maxQuadras = calculateMaxQuadras(playersCount, modeForCalculation);
        
        quadrasInput.min = 1;
        quadrasInput.max = Math.max(1, maxQuadras); 

        quadrasInfoSpan.textContent = `(Máximo ${quadrasInput.max} quadra${quadrasInput.max > 1 ? 's' : ''})`;

        if (parseInt(quadrasInput.value) > quadrasInput.max) {
            quadrasInput.value = quadrasInput.max;
        }
    }

    /**
     * Habilita ou desabilita os campos de configuração.
     * @param {boolean} disabled - True para desabilitar, False para habilitar.
     */
    function setConfigurationFieldsDisabled(disabled) {
        // Os radios de modo de jogo são controlados diretamente no loadGameState
        // radiosModo.forEach(radio => radio.disabled = disabled); 
        jogadoresTextArea.disabled = disabled;
        pote1TextArea.disabled = disabled;
        pote2TextArea.disabled = disabled;
        quadrasInput.disabled = disabled;
        btnSortear.disabled = disabled; // Desabilita o botão de sortear também
        
        // Esconde as opções de pote se estiver desabilitado
        if (disabled) {
            poteOptionsDiv.style.display = 'none';
        }
    }

    // --- Funções de Geração de Jogos ---

    /**
     * Gera todos os jogos possíveis para o modo "Individual sem Pote" usando Round-Robin
     * e os distribui sequencialmente pelas quadras disponíveis.
     * Garante que todos os jogos sejam gerados, independentemente do número de quadras,
     * e os atribui a rodadas e quadras de forma sequential.
     * @param {Array<string>} players - Lista de nomes dos jogadores.
     * @returns {Array<Object>} Lista de jogos gerados com rodada e quadra atribuídas.
     */
    function generateGamesIndividualNoPot(players) {
        let allPlayers = [...players];
        const n = allPlayers.length;

        if (n < 4) {
            showAlert("Para o modo 'Individual sem pote', você precisa de pelo menos 4 jogadores para formar duplas.");
            return [];
        }

        let tempPlayers = [...allPlayers];
        let effectiveN = n;
        
        if (effectiveN % 2 !== 0) {
            tempPlayers.push('Livre');
            effectiveN++;
        }

        const numRoundsTheoretical = effectiveN - 1; // Número de rodadas teóricas do Round-Robin
        let allPotentialGames = [];

        for (let r = 0; r < numRoundsTheoretical; r++) {
            let roundDuos = [];
            const fixedPlayer = tempPlayers[0];
            const rotatingPlayers = tempPlayers.slice(1);

            for (let i = 0; i < effectiveN / 2; i++) {
                let p1, p2;
                if (i === 0) {
                    p1 = fixedPlayer;
                    p2 = rotatingPlayers[rotatingPlayers.length - 1 - i];
                } else {
                    p1 = rotatingPlayers[i - 1];
                    p2 = rotatingPlayers[rotatingPlayers.length - 1 - i];
                }
                roundDuos.push([p1, p2]);
            }
            
            shuffle(roundDuos); // Embaralha as duplas dentro da rodada

            const playableDuos = roundDuos.filter(duo => !duo.includes('Livre'));
            for (let i = 0; i < playableDuos.length; i += 2) {
                if (i + 1 < playableDuos.length) {
                    allPotentialGames.push({
                        duplaA: playableDuos[i],
                        duplaB: playableDuos[i + 1],
                        gamesDuplaA: 0, // Inicializa com 0
                        gamesDuplaB: 0  // Inicializa com 0
                    });
                }
            }

            const lastPlayer = rotatingPlayers.pop();
            rotatingPlayers.unshift(lastPlayer);
            tempPlayers = [fixedPlayer, ...rotatingPlayers];
        }

        // Agora, distribua todos os jogos potenciais pelas quadras sequencialmente
        let finalGames = [];
        const numQuadras = parseInt(quadrasInput.value);
        let currentRound = 1;
        let currentQuadra = 1;

        allPotentialGames.forEach(game => {
            finalGames.push({
                ...game,
                rodada: currentRound,
                quadra: currentQuadra
            });

            currentQuadra++;
            if (currentQuadra > numQuadras) {
                currentQuadra = 1;
                currentRound++; // Avança para a próxima "mini-rodada" quando todas as quadras foram usadas
            }
        });
        
        return finalGames;
    }

    /**
     * Gera jogos para o modo "Individual com Pote", garantindo que cada dupla PoteA-PoteB
     * seja única ao longo de todo o torneio, e que cada jogo tenha 4 jogadores únicos.
     * Tenta encontrar uma solução que balanceie os jogos entre os jogadores, priorizando quem jogou menos recentemente.
     * Prioriza a variação nas duplas adversárias.
     * @param {Array<string>} pote1 - Jogadores do Pote 1.
     * @param {Array<string>} pote2 - Jogadores do Pote 2.
     * @returns {Array<Object>} Lista de jogos gerados.
     */
    function generateGamesIndividualWithPot(pote1, pote2) {
        const numPote1 = pote1.length;
        const numPote2 = pote2.length;
        const numQuadras = parseInt(quadrasInput.value);

        if (numPote1 < 2 || numPote2 < 2) {
            showAlert("Para o modo 'Individual com pote', você precisa de pelo menos 2 jogadores em cada pote para formar jogos válidos (dupla contra dupla).");
            return [];
        }

        let allPlayers = [...pote1, ...pote2];
        let lastPlayedRound = {};
        allPlayers.forEach(p => (lastPlayedRound[p] = -1));
        
        // Gerar todas as duplas possíveis de (Pote1, Pote2)
        let allPossibleP1P2Duos = [];
        pote1.forEach(pA => {
            pote2.forEach(pB => {
                allPossibleP1P2Duos.push([pA, pB]);
            });
        });
        
        let finalGames = [];
        let usedP1P2DuosInTournament = new Set(); // Duplas [PoteA, PoteB] que já foram usadas como parceiras
        let usedPlayerPairsAsOpponents = new Set(); // Para controlar quem já jogou contra quem

        // Helper para verificar se 4 jogadores são únicos
        const arePlayersUnique = (pA1, pB1, pA2, pB2) => {
            return new Set([pA1, pB1, pA2, pB2]).size === 4;
        };

        // Helper para verificar se duas duplas já se enfrentaram
        const haveDuosPlayedBefore = (duo1, duo2) => {
            const players = [...duo1, ...duo2].sort(); // Normaliza a ordem para comparação
            return usedPlayerPairsAsOpponents.has(players.join('|'));
        };

        // Helper para marcar duplas como adversárias
        const markDuosAsOpponents = (duo1, duo2) => {
            const players = [...duo1, ...duo2].sort();
            usedPlayerPairsAsOpponents.add(players.join('|'));
        };

        let rodadaCounter = 1;
        
        // Coleta todos os jogos possíveis antes de atribuir rodadas/quadras
        let allGeneratedGames = [];

        let safetyBreak = 0; // Para evitar loops infinitos em caso de lógicas complexas
        const MAX_ITERATIONS = 500; // Limite de iterações para encontrar jogos

        while (safetyBreak < MAX_ITERATIONS) { // Tenta gerar um número razoável de rodadas
            let gamesThisRoundAttempt = [];
            let playersUsedInCurrentAttempt = new Set(); 
            let availableP1P2Duos = allPossibleP1P2Duos.filter(duo => !usedP1P2DuosInTournament.has(duo.join('|')));
            
            shuffle(availableP1P2Duos); // Embaralha para tentar novas combinações

            // Sort by inactivity to prioritize players who haven't played recently
            availableP1P2Duos.sort((duo1, duo2) => {
                const lp1_1 = lastPlayedRound[duo1[0]];
                const lp1_2 = lastPlayedRound[duo1[1]];
                const lp2_1 = lastPlayedRound[duo2[0]];
                const lp2_2 = lastPlayedRound[duo2[1]];

                const inactivitySum1 = (rodadaCounter - lp1_1) + (rodadaCounter - lp1_2);
                const inactivitySum2 = (rodadaCounter - lp2_1) + (rodadaCounter - lp2_2);

                return inactivitySum2 - inactivitySum1; // Mais inativo primeiro
            });


            // Tentar formar os jogos para esta rodada
            for (let i = 0; i < availableP1P2Duos.length; i++) {
                const teamA = availableP1P2Duos[i];
                if (playersUsedInCurrentAttempt.has(teamA[0]) || playersUsedInCurrentAttempt.has(teamA[1])) {
                    continue;
                }

                // Inner loop para encontrar oponente para teamA
                for (let j = i + 1; j < availableP1P2Duos.length; j++) {
                    const teamB = availableP1P2Duos[j];
                    if (playersUsedInCurrentAttempt.has(teamB[0]) || playersUsedInCurrentAttempt.has(teamB[1])) {
                        continue;
                    }

                    // Verifica se os 4 jogadores são únicos
                    if (!arePlayersUnique(teamA[0], teamA[1], teamB[0], teamB[1])) {
                        continue;
                    }
                    
                    // Verifica se essa combinação de duplas já se enfrentou
                    if (haveDuosPlayedBefore(teamA, teamB)) {
                        continue;
                    }

                    // Se chegamos aqui, temos um jogo válido para esta rodada
                    gamesThisRoundAttempt.push({ 
                        duplaA: teamA, 
                        duplaB: teamB,
                        gamesDuplaA: 0, // Inicializa com 0
                        gamesDuplaB: 0  // Inicializa com 0
                    });
                    
                    playersUsedInCurrentAttempt.add(teamA[0]);
                    playersUsedInCurrentAttempt.add(teamA[1]);
                    playersUsedInCurrentAttempt.add(teamB[0]);
                    playersUsedInCurrentAttempt.add(teamB[1]);

                    // Marca as duplas e os adversários como usados imediatamente para evitar repetição nesta busca
                    usedP1P2DuosInTournament.add(teamA.join('|'));
                    usedP1P2DuosInTournament.add(teamB.join('|'));
                    markDuosAsOpponents(teamA, teamB); 
                    
                    if (gamesThisRoundAttempt.length >= numQuadras) { // Limita jogos por rodada
                        break; 
                    }
                }
                if (gamesThisRoundAttempt.length >= numQuadras) { // Limita jogos por rodada
                    break;
                }
            }
            
            if (gamesThisRoundAttempt.length === 0) {
                // Se não conseguimos formar nenhum jogo nesta tentativa, saímos
                // Isso pode acontecer se todas as combinações válidas já foram usadas
                break; 
            }

            // Adiciona os jogos encontrados para esta rodada à lista completa de jogos
            allGeneratedGames.push(...gamesThisRoundAttempt);

            // Atualiza a última rodada jogada para os jogadores que participaram
            playersUsedInCurrentAttempt.forEach(player => {
                lastPlayedRound[player] = rodadaCounter;
            });

            rodadaCounter++;
            safetyBreak++;
        }
        
        // Atribui rodada e quadra sequencialmente a TODOS os jogos gerados
        let currentAssignedRound = 1;
        let currentAssignedQuadra = 1;
        allGeneratedGames.forEach(game => {
            finalGames.push({
                ...game,
                rodada: currentAssignedRound,
                quadra: currentAssignedQuadra
            });
            currentAssignedQuadra++;
            if (currentAssignedQuadra > numQuadras) {
                currentAssignedQuadra = 1;
                currentAssignedRound++;
            }
        });

        return finalGames;
    }


    /**
     * Gera duplas fixas a partir de uma lista de jogadores.
     * Se houver um número ímpar de jogadores, o último jogador é pareado com 'Livre'.
     * Armazena as duplas geradas em fixedDuosMap para uso na classificação.
     * @param {Array<string>} players - Lista de nomes dos jogadores.
     * @returns {Array<Array<string>>} Lista de duplas fixas.
     */
    function generateFixedDuos(players) {
        const shuffledPlayers = [...players];
        shuffle(shuffledPlayers);
        let duos = [];
        fixedDuosMap = {}; // Reseta o mapa de duplas fixas
        for (let i = 0; i < shuffledPlayers.length; i += 2) {
            let duo;
            if (i + 1 < shuffledPlayers.length) {
                duo = [shuffledPlayers[i], shuffledPlayers[i + 1]].sort(); // Ordena para chave consistente
            } else {
                duo = [shuffledPlayers[i], 'Livre'].sort();
            }
            duos.push(duo);
            // Mapeia cada jogador à sua dupla (ordenada alfabeticamente)
            fixedDuosMap[duo[0]] = duo.join(' & ');
            fixedDuosMap[duo[1]] = duo.join(' & ');
        }
        return duos;
    }

    /**
     * Gera duplas fixas combinando jogadores de dois potes.
     * Cada jogador do Pote 1 é pareado com um jogador do Pote 2.
     * Armazena as duplas geradas em fixedDuosMap para uso na classificação.
     * @param {Array<string>} pote1 - Jogadores do Pote 1.
     * @param {Array<string>} pote2 - Jogadores do Pote 2.
     * @returns {Array<Array<string>>} Lista de duplas fixas.
     */
    function generateFixedDuosWithPot(pote1, pote2) {
        const shuffledPot1 = [...pote1];
        const shuffledPot2 = [...pote2];
        shuffle(shuffledPot1);
        shuffle(shuffledPot2);

        let duos = [];
        fixedDuosMap = {}; // Reseta o mapa de duplas fixas
        const minLength = Math.min(shuffledPot1.length, shuffledPot2.length);

        for (let i = 0; i < minLength; i++) {
            const duo = [shuffledPot1[i], shuffledPot2[i]].sort(); // Ordena para chave consistente
            duos.push(duo);
            // Mapeia cada jogador à sua dupla (ordenada alfabeticamente)
            fixedDuosMap[duo[0]] = duo.join(' & ');
            fixedDuosMap[duo[1]] = duo.join(' & ');
        }
        return duos;
    }

    /**
     * Gera todos os jogos possíveis para o modo "Dupla Fixa com Pote" usando Round-Robin
     * e os distribui sequencialmente pelas quadras disponíveis.
     * @param {Array<string>} pote1 - Jogadores do Pote 1.
     * @param {Array<string>} pote2 - Jogadores do Pote 2.
     * @returns {Array<Object>} Lista de jogos gerados com rodada e quadra atribuída.
     */
    function generateGamesFixedDuoWithPot(pote1, pote2) {
        const fixedDuos = generateFixedDuosWithPot(pote1, pote2); // Gera e popula fixedDuosMap
        let allPotentialGames = [];
        const numQuadras = parseInt(quadrasInput.value);

        let tempDuos = [...fixedDuos];
        if (tempDuos.length % 2 !== 0) {
            tempDuos.push(['Livre', 'Livre']);
        }

        const numDuplas = tempDuos.length;
        const numRoundsTheoretical = numDuplas - 1;

        for (let r = 0; r < numRoundsTheoretical; r++) {
            let gamesInRoundTheoretical = [];
            for (let i = 0; i < numDuplas / 2; i++) {
                const duplaA = tempDuos[i];
                const duplaB = tempDuos[numDuplas - 1 - i];
                
                if (!duplaA.includes('Livre') && !duplaB.includes('Livre')) {
                    gamesInRoundTheoretical.push({ 
                        duplaA: duplaA, 
                        duplaB: duplaB,
                        gamesDuplaA: 0, // Inicializa com 0
                        gamesDuplaB: 0  // Inicializa com 0
                    });
                }
            }
            // Adiciona todos os jogos teóricos da rodada à lista geral
            allPotentialGames.push(...gamesInRoundTheoretical);

            const firstDuo = tempDuos[0];
            const rotatingDuos = tempDuos.slice(1);
            const lastDuo = rotatingDuos.pop();
            rotatingDuos.unshift(lastDuo);
            tempDuos = [firstDuo, ...rotatingDuos];
        }

        // Agora, distribua todos os jogos potenciais pelas quadras sequencialmente
        let finalGames = [];
        let currentRound = 1;
        let currentQuadra = 1;
        allPotentialGames.forEach(game => {
            finalGames.push({
                ...game,
                rodada: currentRound,
                quadra: currentQuadra
            });
            currentQuadra++;
            if (currentQuadra > numQuadras) {
                currentQuadra = 1;
                currentRound++;
            }
        });
        return finalGames;
    }

    // --- Funções de Exibição e Gerenciamento ---

    /**
     * Exibe os jogos gerados na tabela da aba "Jogos", utilizando as propriedades 'rodada' e 'quadra'
     * já definidas na geração dos jogos.
     * @param {Array<Object>} games - Lista de jogos a serem exibidos.
     */
    function displayGames(games) {
        tabelaJogosBody.innerHTML = ''; // Limpa a tabela

        if (games.length === 0) {
            tabelaJogosBody.innerHTML = '<tr><td colspan="5">Nenhum jogo gerado. Verifique os jogadores e o modo de jogo.</td></tr>';
            return;
        }

        games.forEach((game, i) => {
            const row = document.createElement('tr');

            const roundCell = document.createElement('td');
            roundCell.classList.add('col-rodada'); // Adiciona a classe
            roundCell.textContent = game.rodada;
            row.appendChild(roundCell);

            const courtCell = document.createElement('td');
            courtCell.classList.add('col-quadra'); // Adiciona a classe
            courtCell.textContent = game.quadra;
            row.appendChild(courtCell);

            const teamACell = document.createElement('td');
            teamACell.textContent = Array.isArray(game.duplaA) ? game.duplaA.join(' & ') : game.duplaA;
            row.appendChild(teamACell);

            const resultCell = document.createElement('td'); // Célula do resultado
            const isTeamALibre = Array.isArray(game.duplaA) && game.duplaA.includes('Livre');
            const isTeamBLibre = Array.isArray(game.duplaB) && game.duplaB.includes('Livre');

            if (!isTeamALibre && !isTeamBLibre) {
                const inputA = document.createElement('input');
                inputA.type = 'number';
                inputA.min = 0;
                inputA.className = 'result-input';
                inputA.dataset.gameIndex = i;
                inputA.dataset.team = 'A';
                if (game.gamesDuplaA !== undefined) inputA.value = game.gamesDuplaA;

                const inputB = document.createElement('input');
                inputB.type = 'number';
                inputB.min = 0;
                inputB.className = 'result-input';
                inputB.dataset.gameIndex = i;
                inputB.dataset.team = 'B';
                if (game.gamesDuplaB !== undefined) inputB.value = game.gamesDuplaB;

                inputA.addEventListener('change', updateResult);
                inputB.addEventListener('change', updateResult);

                resultCell.appendChild(inputA);
                resultCell.appendChild(document.createTextNode(' x '));
                resultCell.appendChild(inputB);
            } else {
                resultCell.textContent = '-';
            }
            row.appendChild(resultCell); // Adiciona a célula de resultado

            const teamBCell = document.createElement('td');
            teamBCell.textContent = Array.isArray(game.duplaB) ? game.duplaB.join(' & ') : game.duplaB;
            row.appendChild(teamBCell);

            tabelaJogosBody.appendChild(row);
        });
    }

    /**
     * Atualiza o resultado de um jogo no array `generatedGames`, recalcula a classificação
     * e salva o estado do jogo.
     * @param {Event} event - O evento de mudança do input de resultado.
     */
    function updateResult(event) {
        const input = event.target;
        const gameIndex = parseInt(input.dataset.gameIndex);
        const team = input.dataset.team;
        const value = parseInt(input.value);

        if (isNaN(value) || value < 0) {
            showAlert('Por favor, insira um valor válido (0 ou mais) para os games.');
            input.value = '';
            return;
        }

        if (generatedGames[gameIndex]) {
            generatedGames[gameIndex][`gamesDupla${team}`] = value;
            saveGameState();
            // Re-renderiza apenas a classificação para eficiência
            updateClassification();
        }
    }

    /**
     * Atualiza a classificação dos jogadores com base nos resultados dos jogos.
     * Considera os critérios de desempate e determina o campeão.
     * @param {boolean} fromTabSwitch - Indica se a função foi chamada por uma troca de aba.
     */
    function updateClassification(fromTabSwitch = false) {
        const playerStats = {}; // { 'NomeJogador': { vitorias: N, derrotas: N, saldoGames: N, gamesGanhos: N, gamesPerdidos: N } }
        let allPlayers = new Set();
        let isFixedDuoMode = currentMode.includes('dupla-fixa');

        // Coleta todos os jogadores/duplas e inicializa estatísticas
        if (isFixedDuoMode) {
            if (currentMode.includes('com-pote')) {
                const pote1 = parsePlayerInput(pote1TextArea.value);
                const pote2 = parsePlayerInput(pote2TextArea.value);
                generateFixedDuosWithPot(pote1, pote2); // Popula fixedDuosMap
            } else {
                const players = parsePlayerInput(jogadoresTextArea.value);
                generateFixedDuos(players); // Popula fixedDuosMap
            }
            // Adiciona as duplas fixas como "jogadores" para a classificação
            Object.values(fixedDuosMap).forEach(duoName => {
                if (!playerStats[duoName]) {
                    playerStats[duoName] = { vitorias: 0, derrotas: 0, saldoGames: 0, gamesGanhos: 0, gamesPerdidos: 0, jogosDisputados: 0 };
                    allPlayers.add(duoName);
                }
            });
            headerName.textContent = 'Dupla';
        } else {
            if (currentMode.includes('com-pote')) {
                const pote1 = parsePlayerInput(pote1TextArea.value);
                const pote2 = parsePlayerInput(pote2TextArea.value);
                [...pote1, ...pote2].forEach(player => {
                    if (!playerStats[player]) {
                        playerStats[player] = { vitorias: 0, derrotas: 0, saldoGames: 0, gamesGanhos: 0, gamesPerdidos: 0, jogosDisputados: 0 };
                        allPlayers.add(player);
                    }
                });
            } else {
                parsePlayerInput(jogadoresTextArea.value).forEach(player => {
                    if (!playerStats[player]) {
                        playerStats[player] = { vitorias: 0, derrotas: 0, saldoGames: 0, gamesGanhos: 0, gamesPerdidos: 0, jogosDisputados: 0 };
                        allPlayers.add(player);
                    }
                });
            }
            headerName.textContent = 'Jogador';
        }

        let allGamesCompleted = true; // Flag para verificar se todos os jogos têm resultados

        // Processa os jogos e calcula as estatísticas
        generatedGames.forEach(game => {
            // Verifica se o jogo tem resultados inseridos e não é um jogo com "Livre"
            const isGameComplete = (game.gamesDuplaA !== undefined && game.gamesDuplaB !== undefined && 
                                   !game.duplaA.includes('Livre') && !game.duplaB.includes('Livre'));
            
            if (!isGameComplete) {
                allGamesCompleted = false; // Há pelo menos um jogo incompleto
                return; // Pula este jogo se estiver incompleto ou tiver "Livre"
            }

            const scoreA = game.gamesDuplaA;
            const scoreB = game.gamesDuplaB;

            // Se for modo de dupla fixa, os "jogadores" são as duplas
            let playerA_identifier, playerB_identifier;
            if (isFixedDuoMode) {
                playerA_identifier = Array.isArray(game.duplaA) ? game.duplaA.join(' & ') : game.duplaA;
                playerB_identifier = Array.isArray(game.duplaB) ? game.duplaB.join(' & ') : game.duplaB;
                
                // Assegura que as estatísticas da dupla existam
                if (!playerStats[playerA_identifier]) {
                    playerStats[playerA_identifier] = { vitorias: 0, derrotas: 0, saldoGames: 0, gamesGanhos: 0, gamesPerdidos: 0, jogosDisputados: 0 };
                }
                if (!playerStats[playerB_identifier]) {
                    playerStats[playerB_identifier] = { vitorias: 0, derrotas: 0, saldoGames: 0, gamesGanhos: 0, gamesPerdidos: 0, jogosDisputados: 0 };
                }

                playerStats[playerA_identifier].gamesGanhos += scoreA;
                playerStats[playerA_identifier].gamesPerdidos += scoreB;
                playerStats[playerA_identifier].saldoGames += (scoreA - scoreB);
                playerStats[playerA_identifier].jogosDisputados++;

                playerStats[playerB_identifier].gamesGanhos += scoreB;
                playerStats[playerB_identifier].gamesPerdidos += scoreA;
                playerStats[playerB_identifier].saldoGames += (scoreB - scoreA);
                playerStats[playerB_identifier].jogosDisputados++;

                if (scoreA > scoreB) {
                    playerStats[playerA_identifier].vitorias++;
                    playerStats[playerB_identifier].derrotas++;
                } else if (scoreB > scoreA) {
                    playerStats[playerB_identifier].vitorias++;
                    playerStats[playerA_identifier].derrotas++;
                }
            } else {
                // Para modo individual, processa cada jogador dentro das duplas
                game.duplaA.forEach(player => {
                    // Inicializa gamesGanhos e gamesPerdidos para cada jogador se ainda não estiverem definidos
                    if (!playerStats[player]) playerStats[player] = { vitorias: 0, derrotas: 0, saldoGames: 0, gamesGanhos: 0, gamesPerdidos: 0, jogosDisputados: 0 };
                    playerStats[player].gamesGanhos = (playerStats[player].gamesGanhos || 0) + scoreA;
                    playerStats[player].gamesPerdidos = (playerStats[player].gamesPerdidos || 0) + scoreB;
                    playerStats[player].saldoGames = (playerStats[player].saldoGames || 0) + (scoreA - scoreB);
                    playerStats[player].jogosDisputados = (playerStats[player].jogosDisputados || 0) + 1;
                });
                game.duplaB.forEach(player => {
                    if (!playerStats[player]) playerStats[player] = { vitorias: 0, derrotas: 0, saldoGames: 0, gamesGanhos: 0, gamesPerdidos: 0, jogosDisputados: 0 };
                    playerStats[player].gamesGanhos = (playerStats[player].gamesGanhos || 0) + scoreB;
                    playerStats[player].gamesPerdidos = (playerStats[player].gamesPerdidos || 0) + scoreA;
                    playerStats[player].saldoGames = (playerStats[player].saldoGames || 0) + (scoreB - scoreA);
                    playerStats[player].jogosDisputados = (playerStats[player].jogosDisputados || 0) + 1;
                });

                // Lógica de vitórias/derrotas para modo individual
                if (scoreA > scoreB) {
                    game.duplaA.forEach(player => playerStats[player].vitorias++);
                    game.duplaB.forEach(player => playerStats[player].derrotas++);
                } else if (scoreB > scoreA) {
                    game.duplaB.forEach(player => playerStats[player].vitorias++);
                    game.duplaA.forEach(player => playerStats[player].derrotas++);
                }
            }
        });

        // Converte o objeto de estatísticas em um array e ordena
        let classification = Object.keys(playerStats).map(name => ({
            name: name,
            ...playerStats[name]
        }));

        classification.sort((a, b) => {
            // 1. Maior número de vitórias
            if (b.vitorias !== a.vitorias) {
                return b.vitorias - a.vitorias;
            }
            // 2. Maior saldo de games
            if (b.saldoGames !== a.saldoGames) {
                return b.saldoGames - a.saldoGames;
            }
            // 3. Confronto Direto (apenas se for dupla, individual com pote ou individual sem pote)
            // Esta lógica precisa ser mais complexa para duplas ou individuais com múltiplos jogos diretos.
            // Para simplificar, vou assumir um confronto direto entre os dois que estão empatados
            // e se houve um único jogo entre eles.
            // Lógica de confronto direto a ser implementada se necessário um desempate mais robusto
            // Por enquanto, apenas para a lógica mais simples:
            if (a.name !== 'Livre' && b.name !== 'Livre') {
                if (!isFixedDuoMode) { // Para modos individuais
                    const directGame = generatedGames.find(game => {
                        const playersInGame = [...game.duplaA, ...game.duplaB];
                        return playersInGame.includes(a.name) && playersInGame.includes(b.name) &&
                               game.gamesDuplaA !== undefined && game.gamesDuplaB !== undefined;
                    });
                    if (directGame) {
                        const aPlayedAsA = directGame.duplaA.includes(a.name);
                        const bPlayedAsA = directGame.duplaA.includes(b.name);
                        const aPlayedAsB = directGame.duplaB.includes(a.name);
                        const bPlayedAsB = directGame.duplaB.includes(b.name);

                        if ((aPlayedAsA && bPlayedAsB) || (aPlayedAsB && bPlayedAsA)) { // Eles foram adversários diretos
                            if (aPlayedAsA) return directGame.gamesDuplaB - directGame.gamesDuplaA; // B ganhou contra A
                            if (aPlayedAsB) return directGame.gamesDuplaA - directGame.gamesDuplaB; // A ganhou contra B
                        }
                    }
                } else { // Para modo de dupla fixa
                     const directGame = generatedGames.find(game => {
                        const gameDuplaA = game.duplaA.join(' & ');
                        const gameDuplaB = game.duplaB.join(' & ');
                        return ((gameDuplaA === a.name && gameDuplaB === b.name) ||
                                (gameDuplaA === b.name && gameDuplaB === a.name)) &&
                               game.gamesDuplaA !== undefined && game.gamesDuplaB !== undefined;
                    });

                    if (directGame) {
                        if (directGame.duplaA.join(' & ') === a.name) { // 'a' era Dupla A no jogo
                            return directGame.gamesDuplaB - directGame.gamesDuplaA; // Se B ganhou, a.vitorias - b.vitorias será negativo, b sobe
                        } else { // 'a' era Dupla B no jogo
                            return directGame.gamesDuplaA - directGame.gamesDuplaB; // Se A ganhou, a.vitorias - b.vitorias será positivo, a sobe
                        }
                    }
                }
            }
            return 0; // Mantém a ordem original se nenhum critério de desempate se aplicar
        });

        // Limpa a tabela de resultados
        tabelaResultadoBody.innerHTML = '';

        if (classification.length === 0) {
            tabelaResultadoBody.innerHTML = '<tr><td colspan="7">Nenhum resultado para exibir. Gere jogos e insira os placares.</td></tr>';
            return;
        }

        // Preenche a tabela de resultados
        classification.forEach((stats, index) => {
            const row = document.createElement('tr');
            const nameCellContent = stats.name === 'Livre' ? 'Livre' : stats.name;

            row.innerHTML = `
                <td>${index + 1}º</td>
                <td>${nameCellContent}</td>
                <td>${stats.vitorias}</td>
                <td>${stats.derrotas}</td>
                <td>${stats.saldoGames}</td>
                <td>${stats.gamesGanhados}</td>
                <td>${stats.gamesPerdidos}</td>
            `;
            tabelaResultadoBody.appendChild(row);
        });

        // Exibe alerta do campeão se todos os jogos estiverem completos E a chamada veio de troca de aba
        if (allGamesCompleted && fromTabSwitch) {
            const champion = classification[0];
            if (champion && champion.name !== 'Livre') {
                showAlert(`Parabéns! O campeão é: ${champion.name} com ${champion.vitorias} vitórias!`);
            } else if (champion && champion.name === 'Livre' && classification.length > 1) {
                 const actualChampion = classification[1]; // Pega o segundo se o primeiro for 'Livre'
                 showAlert(`Parabéns! O campeão é: ${actualChampion.name} com ${actualChampion.vitorias} vitórias!`);
            } else {
                 showAlert('Preencha todos os resultados dos jogos para ver o campeão!');
            }
        } else if (!allGamesCompleted && fromTabSwitch) {
            showAlert('Preencha todos os resultados dos jogos para ver o campeão!');
        }
    }


    /**
     * Reseta o estado da aplicação, limpando dados salvos no localStorage.
     * @param {boolean} clearSavedState - Indica se deve limpar o localStorage.
     */
    function resetApplicationState(clearSavedState) {
        generatedGames = [];
        fixedDuosMap = {};
        tabelaJogosBody.innerHTML = '<tr><td colspan="5">Nenhum jogo gerado.</td></tr>';
        tabelaResultadoBody.innerHTML = '<tr><td colspan="7">Nenhum resultado para exibir.</td></tr>';

        // Restaura valores padrão dos campos de configuração
        document.querySelector('input[name="modo"][value="individual-sem-pote"]').checked = true;
        currentMode = 'individual-sem-pote';
        campoComPote.style.display = 'none';
        campoSemPote.style.display = 'block';
        jogadoresTextArea.value = ''; // Limpa os campos
        pote1TextArea.value = '';     // Limpa os campos
        pote2TextArea.value = '';     // Limpa os campos
        quadrasInput.value = 1;
        poteOptionsDiv.style.display = 'none';
        playerActionInfoDiv.style.display = 'none';

        setConfigurationFieldsDisabled(false);
        radiosModo.forEach(radio => radio.disabled = false); // Habilita os radios

        if (clearSavedState) {
            localStorage.removeItem(LOCAL_STORAGE_KEY_GAMES);
            localStorage.removeItem(LOCAL_STORAGE_KEY_CONFIG);
            localStorage.removeItem(LOCAL_STORAGE_KEY_MODE_LOCKED);
            localStorage.removeItem(LOCAL_STORAGE_KEY_FIXED_DUOS);
            showAlert('Todas as informações foram apagadas e o aplicativo foi reiniciado.');
        }
        updateQuadrasInputLimits(); // Garante que os limites da quadra sejam atualizados após o reset
    }

    /**
     * Lida com o sorteio dos jogos com base no modo de jogo selecionado.
     */
    function handleSortGames() {
        if (localStorage.getItem(LOCAL_STORAGE_KEY_MODE_LOCKED) === 'true') {
            showAlert('O sorteio já foi realizado. Se deseja mudar o modo de jogo, clique em "Reiniciar" para apagar os dados atuais.');
            return;
        }

        let players;
        let pote1, pote2;

        if (currentMode.includes('com-pote')) {
            pote1 = parsePlayerInput(pote1TextArea.value);
            pote2 = parsePlayerInput(pote2TextArea.value);

            if (pote1.length === 0 || pote2.length === 0) {
                showAlert("Por favor, preencha os jogadores em ambos os potes.");
                return;
            }

            if (currentMode === 'individual-com-pote') {
                generatedGames = generateGamesIndividualWithPot(pote1, pote2);
            } else if (currentMode === 'dupla-fixa-com-pote') {
                if (pote1.length !== pote2.length) {
                    showAlert("Para duplas fixas com pote, os potes devem ter o mesmo número de jogadores para formar duplas completas. Ajuste os jogadores ou mude o modo.");
                    return;
                }
                generatedGames = generateGamesFixedDuoWithPot(pote1, pote2);
            }
        } else {
            players = parsePlayerInput(jogadoresTextArea.value);
            if (players.length === 0) {
                showAlert("Por favor, insira os nomes dos jogadores.");
                return;
            }

            if (currentMode === 'individual-sem-pote') {
                generatedGames = generateGamesIndividualNoPot(players);
            } else if (currentMode === 'dupla-fixa-sem-pote') {
                // Chama a função para gerar jogos de dupla fixa sem pote
                // É preciso ter essa função implementada! (se não está, é um bug)
                // Assumindo que `generateGamesFixedDuoNoPot` existe ou será criada.
                // Por agora, vou deixar um placeholder ou uma mensagem de erro se a função não existir.
                showAlert("A função para 'Dupla fixa sem pote' ainda não foi implementada ou possui erros.");
                generatedGames = []; // Para evitar crash se a função não existir
            }
        }

        if (generatedGames.length === 0) {
            showAlert("Não foi possível gerar jogos com as configurações atuais. Verifique o número de jogadores e o modo de jogo.");
            return;
        }
        
        displayGames(generatedGames); 
        updateClassification(); // Não mostra pop-up de campeão no sorteio inicial
        saveGameState(); 
        setConfigurationFieldsDisabled(true); 
        // Trava os radios de modo após o sorteio
        radiosModo.forEach(radio => radio.disabled = true);
        
        showAlert('Os jogos foram criados com sucesso!'); // Alerta de sorteio
    }

    // --- Associações de Eventos ---
    document.getElementById('btnSortear').addEventListener('click', handleSortGames);

    document.getElementById('btnReiniciar').addEventListener('click', () => {
        if (confirm('Tem certeza que deseja reiniciar e apagar todas as informações?')) {
            resetApplicationState(true); 
            tabButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector('button[data-tab="config"]').classList.add('active');
            sections.forEach(sec => {
                if (sec.id === 'config') sec.classList.add('active');
                else sec.classList.remove('active');
            });
        }
    });

    // Carrega o estado do jogo ao carregar a página
    window.addEventListener('load', loadGameState);

</script>
</body>
</html>
