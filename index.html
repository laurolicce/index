<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Super 8 - Beach Tennis</title>
<style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      margin: 0; padding: 0; background: #f0f2f5; color: #333;
      display: flex !important; /* CORREÇÃO APLICADA AQUI */
      flex-direction: column; /* Organiza itens em coluna */
      min-height: 100vh; /* Garante que o body ocupe a altura total da tela */
    }
    header {
      background: #2980b9; color: white; padding: 1rem; text-align: center;
      font-weight: 700; font-size: 1.4rem;
    }
    main {
      max-width: 900px; /* Largura máxima fixa para evitar redimensionamento */
      width: 100%; /* Garante que ocupe a largura total dentro do max-width */
      margin: 1rem auto; /* Centraliza o main */
      background: white; border-radius: 8px; box-shadow: 0 0 10px rgb(0 0 0 / 0.1);
      padding: 1rem 2rem 2rem 2rem;
      /* Removido flex-grow: 1 para evitar que ele se expanda e contraia */
    }
    nav {
      display: flex; border-bottom: 2px solid #2980b9; margin-bottom: 1rem;
    }
    nav button {
      flex: 1; background: transparent; border: none; padding: 1rem; font-size: 1rem; cursor: pointer; font-weight: 600; color: #2980b9;
      border-bottom: 3px solid transparent; transition: 0.3s ease;
    }
    nav button.active {
      border-bottom-color: #2980b9; color: #145a86;
    }
    section {
      display: none;
    }
    section.active {
      display: block;
    }
    label {
      display: block; margin-top: 0.8rem; font-weight: 600;
    }
    textarea, input[type=text] {
      width: 100%; padding: 8px; margin-top: 0.3rem; border-radius: 4px; border: 1px solid #ccc; font-size: 1rem;
      box-sizing: border-box;
    }
    textarea {
      resize: vertical;
    }
    fieldset {
      border: 1px solid #ccc; border-radius: 5px; padding: 10px 15px 15px 15px; margin-top: 1rem;
    }
    legend {
      font-weight: 700; color: #2980b9; padding: 0 6px;
    }
    button.action-btn {
      background: #2980b9; color: white; border: none; padding: 10px 20px; margin-top: 15px; border-radius: 5px; cursor: pointer;
      font-weight: 700; margin-right: 10px; /* Espaço entre botões */
    }
    button.action-btn:hover {
      background: #1c5d86;
    }
    button.action-btn:disabled {
        background: #cccccc;
        cursor: not-allowed;
    }
    table {
      width: 100%; border-collapse: collapse; margin-top: 1rem;
    }
    th, td {
      border: 1px solid #ddd; padding: 8px; text-align: center;
    }
    th {
      background: #2980b9; color: white;
    }
    /* Novos estilos para estreitar as colunas de Rodada e Quadra */
    .col-rodada {
        width: 10%; /* Ajuste conforme necessário */
        min-width: 60px; /* Garante um tamanho mínimo */
    }
    .col-quadra {
        width: 10%; /* Ajuste conforme necessário */
        min-width: 60px; /* Garante um tamanho mínimo */
    }

    input.result-input {
      width: 50px; text-align: center; font-weight: 600; font-size: 1rem; border: 1px solid #2980b9; border-radius: 4px;
    }
    .center {
      text-align: center;
    }
    .player-highlight {
        font-weight: bold;
        color: red;
        font-size: 1.1rem;
    }
    .option-buttons {
        margin-top: 15px;
        display: flex;
        gap: 10px;
    }
    #quadrasInputContainer {
        margin-top: 15px;
    }
    #quadrasInputContainer label {
        display: inline-block; /* Para manter o label e o input na mesma linha */
        margin-right: 10px;
    }
    #quadras {
        width: auto; /* Ajusta a largura para caber o número */
        padding: 5px;
        text-align: center;
    }

    /* Estilo para o pop-up */
    .popup {
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 1; /* Sit on top */
        left: 0;
        top: 0;
        width: 100%; /* Full width */
        height: 100%; /* Full height */
        overflow: auto; /* Enable scroll if needed */
        background-color: rgb(0,0,0); /* Fallback color */
        background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        padding-top: 60px;
    }
    .popup-content {
        background-color: #fefefe;
        margin: 15% auto; /* 15% from the top and centered */
        padding: 20px;
        border: 1px solid #888;
        width: 80%; /* Could be more or less, depending on screen size */
        max-width: 400px;
        border-radius: 8px;
        box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
        animation-name: animatetop;
        animation-duration: 0.4s
    }
    @keyframes animatetop {
        from {top: -300px; opacity: 0}
        to {top: 0; opacity: 1}
    }
    .popup-close {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
    }
    .popup-close:hover,
    .popup-close:focus {
        color: black;
        text-decoration: none;
        cursor: pointer;
    }

    footer {
        text-align: center;
        padding: 1rem;
        background: #2980b9;
        color: white;
        margin-top: auto; /* Empurra o rodapé para baixo */
    }

    .criteria-text {
        margin-top: 1rem;
        font-size: 0.9em;
        color: #555;
    }
    .criteria-list {
        margin-left: 1.5rem;
        padding-left: 0;
    }

    @media (max-width: 600px) {
      nav button {
        font-size: 0.9rem;
        padding: 8px;
      }
      table, th, td {
        font-size: 0.8rem;
      }
    }
</style>
</head>
<body>

<header>Super 8 - Beach Tennis</header>

<main>
    <nav>
        <button class="tab-button active" data-tab="config">Configuração</button>
        <button class="tab-button" data-tab="jogos">Jogos</button>
        <button class="tab-button" data-tab="resultado">Resultado</button>
    </nav>

    <section id="config" class="active">
        <fieldset>
            <legend>Modo de Jogo</legend>
            <label><input type="radio" name="modo" value="individual-sem-pote" checked> Individual sem pote</label>
            <label><input type="radio" name="modo" value="individual-com-pote"> Individual com pote</label>
            <label><input type="radio" name="modo" value="dupla-fixa-sem-pote"> Dupla fixa sem pote</label>
            <label><input type="radio" name="modo" value="dupla-fixa-com-pote"> Dupla fixa com pote</label>
        </fieldset>

        <div id="campoSemPote">
            <label for="jogadores">Jogadores (um por linha):</label>
            <textarea id="jogadores" rows="8" placeholder="Exemplo: Lucas&#10;Maria&#10;Pedro&#10;Ana">Lucas
Maria
Pedro
Ana
João
Carla
Paulo
Marina</textarea>
        </div>

        <div id="campoComPote" style="display:none;">
            <label for="pote1">Pote 1 (um por linha):</label>
            <textarea id="pote1" rows="6" placeholder="Exemplo: Lucas&#10;Pedro&#10;João&#10;Paulo">A
B
C
D</textarea>

            <label for="pote2">Pote 2 (um por linha):</label>
            <textarea id="pote2" rows="6" placeholder="Exemplo: Maria&#10;Ana&#10;Carla&#10;Marina">1
2
3
4</textarea>
            <div id="poteOptions" style="display:none;">
                <p>Os potes têm números de jogadores diferentes. Escolha uma opção:</p>
                <div class="option-buttons">
                    <button class="action-btn" id="btnExcludePlayer">Excluir um jogador do pote maior</button>
                    <button class="action-btn" id="btnMovePlayer" style="display:none;">Mover um jogador para o outro pote</button>
                </div>
                <div id="playerActionInfo" class="player-highlight" style="display:none;"></div>
            </div>
        </div>
        
        <div id="quadrasInputContainer">
            <label for="quadras">Quantidade de Quadras:</label>
            <input type="number" id="quadras" value="1" min="1">
            <span id="quadrasInfo" style="font-size: 0.9em; color: #555;"></span>
        </div>

        <button class="action-btn" id="btnSortear">Sortear Jogos</button>
        <button class="action-btn" id="btnReiniciar">Reiniciar</button>
    </section>

    <section id="jogos">
        <table id="tabelaJogos">
            <thead>
                <tr>
                    <th class="col-rodada">Rodada</th>
                    <th class="col-quadra">Quadra</th>
                    <th>Dupla A</th>
                    <th>Resultado (Games)</th> 
                    <th>Dupla B</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
    </section>

    <section id="resultado">
        <table id="tabelaResultado">
            <thead>
                <tr>
                    <th>Posição</th>
                    <th id="headerName">Jogador</th> 
                    <th>Vitórias</th>
                    <th>Derrotas</th>
                    <th>Saldo de Games</th> 
                    <th>Games Ganhados</th>
                    <th>Games Perdidos</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
        <p class="criteria-text">
            **Critérios de Desempate:**
            <ol class="criteria-list">
                <li>Maior número de **Vitórias**</li>
                <li>Maior **Saldo de Games** (Games Ganhados - Games Perdidos)</li>
                <li>Em caso de novo empate, o critério é o **Confronto Direto** (quem ganhou o jogo entre os empatados)</li>
            </ol>
        </p>
    </section>
</main>

<footer>
    © 2025 Todos os direitos reservados. Proibida a cópia ou reprodução.<br>
    Desenvolvido por Lauro Licce.
</footer>

<div id="infoPopup" class="popup">
    <div class="popup-content">
        <span class="popup-close">&times;</span>
        <h3 id="popupTitle"></h3>
        <p id="popupMessage"></p>
    </div>
</div>

<script>
    // Gerenciamento de abas
    const tabButtons = document.querySelectorAll('.tab-button');
    const sections = document.querySelectorAll('main section');

    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            const targetTab = button.dataset.tab;
            sections.forEach(section => {
                if (section.id === targetTab) section.classList.add('active');
                else section.classList.remove('active');
            });
            // Quando muda para a aba de resultado, atualiza a classificação e mostra o pop-up do campeão
            if (targetTab === 'resultado') {
                updateClassification(true); // true para indicar que é uma atualização de tab
            }
        });
    });

    // Referências a elementos DOM
    const radiosModo = document.querySelectorAll('input[name="modo"]');
    const campoSemPote = document.getElementById('campoSemPote');
    const campoComPote = document.getElementById('campoComPote');
    const poteOptionsDiv = document.getElementById('poteOptions');
    const playerActionInfoDiv = document.getElementById('playerActionInfo');
    const btnMovePlayer = document.getElementById('btnMovePlayer');
    const jogadoresTextArea = document.getElementById('jogadores');
    const pote1TextArea = document.getElementById('pote1');
    const pote2TextArea = document.getElementById('pote2');
    const tabelaJogosBody = document.querySelector('#tabelaJogos tbody');
    const tabelaResultadoBody = document.querySelector('#tabelaResultado tbody');
    const headerName = document.getElementById('headerName'); // Cabeçalho dinâmico
    const quadrasInput = document.getElementById('quadras');
    const quadrasInfoSpan = document.getElementById('quadrasInfo');
    const infoPopup = document.getElementById('infoPopup'); // Renomeado
    const popupTitle = document.getElementById('popupTitle');
    const popupMessage = document.getElementById('popupMessage');
    const popupClose = document.querySelector('.popup-close'); // Renomeado
    const btnSortear = document.getElementById('btnSortear');
    const btnReiniciar = document.getElementById('btnReiniciar');

    // Estado global da aplicação
    let generatedGames = [];
    let currentMode = 'individual-sem-pote'; // Modo de jogo inicial
    let fixedDuosMap = {}; // Armazenará as duplas fixas para o torneio

    // Constantes para chaves do localStorage
    const LOCAL_STORAGE_KEY_GAMES = 'super8_generatedGames';
    const LOCAL_STORAGE_KEY_CONFIG = 'super8_config';
    const LOCAL_STORAGE_KEY_MODE_LOCKED = 'super8_modeLocked';
    const LOCAL_STORAGE_KEY_FIXED_DUOS = 'super8_fixedDuos'; // Nova chave para duplas fixas

    // Event listener para mudança de modo de jogo
    radiosModo.forEach(radio => radio.addEventListener('change', () => {
        currentMode = radio.value;
        if (currentMode.includes('com-pote')) {
            campoComPote.style.display = 'block';
            campoSemPote.style.display = 'none';
        } else {
            campoComPote.style.display = 'none';
            campoSemPote.style.display = 'block';
        }
        // Limpa opções de pote e informações de jogador ao mudar o modo
        poteOptionsDiv.style.display = 'none';
        playerActionInfoDiv.style.display = 'none';
        // Não reseta o localStorage aqui, apenas ao clicar em "Reiniciar"
        updateQuadrasInputLimits(); // Atualiza limites de quadras ao mudar o modo/jogadores
    }));

    // Event listener para input de jogadores/potes para atualizar limites de quadra
    jogadoresTextArea.addEventListener('input', updateQuadrasInputLimits);
    pote1TextArea.addEventListener('input', updateQuadrasInputLimits);
    pote2TextArea.addEventListener('input', updateQuadrasInputLimits);

    // Event listener para fechar o pop-up
    popupClose.addEventListener('click', () => {
        infoPopup.style.display = 'none';
    });
    window.addEventListener('click', (event) => {
        if (event.target == infoPopup) {
            infoPopup.style.display = 'none';
        }
    });

    /**
     * Exibe o pop-up com um título e mensagem.
     * @param {string} title - O título do pop-up.
     * @param {string} message - A mensagem a ser exibida no pop-up.
     */
    function showPopup(title, message) {
        popupTitle.textContent = title;
        popupMessage.innerHTML = message; // Usar innerHTML para permitir tags como <br>
        infoPopup.style.display = 'block';
    }

    /**
     * Salva o estado atual do jogo no localStorage.
     */
    function saveGameState() {
        const config = {
            mode: currentMode,
            jogadores: jogadoresTextArea.value,
            pote1: pote1TextArea.value,
            pote2: pote2TextArea.value,
            quadras: quadrasInput.value
        };
        localStorage.setItem(LOCAL_STORAGE_KEY_GAMES, JSON.stringify(generatedGames));
        localStorage.setItem(LOCAL_STORAGE_KEY_CONFIG, JSON.stringify(config));
        localStorage.setItem(LOCAL_STORAGE_KEY_FIXED_DUOS, JSON.stringify(fixedDuosMap));

        if (generatedGames.length > 0) {
            localStorage.setItem(LOCAL_STORAGE_KEY_MODE_LOCKED, 'true');
        } else {
            localStorage.removeItem(LOCAL_STORAGE_KEY_MODE_LOCKED);
        }
    }

    /**
     * Carrega o estado do jogo do localStorage.
     */
    function loadGameState() {
        const savedGames = localStorage.getItem(LOCAL_STORAGE_KEY_GAMES);
        const savedConfig = localStorage.getItem(LOCAL_STORAGE_KEY_CONFIG);
        const modeLocked = localStorage.getItem(LOCAL_STORAGE_KEY_MODE_LOCKED) === 'true';
        const savedFixedDuos = localStorage.getItem(LOCAL_STORAGE_KEY_FIXED_DUOS);

        if (savedConfig) {
            const config = JSON.parse(savedConfig);
            currentMode = config.mode;
            
            document.querySelector(`input[name="modo"][value="${currentMode}"]`).checked = true;

            if (currentMode.includes('com-pote')) {
                campoComPote.style.display = 'block';
                campoSemPote.style.display = 'none';
            } else {
                campoComPote.style.display = 'none';
                campoSemPote.style.display = 'block';
            }

            jogadoresTextArea.value = config.jogadores || 'Lucas\nMaria\nPedro\nAna\nJoão\nCarla\nPaulo\nMarina';
            pote1TextArea.value = config.pote1 || 'A\nB\nC\nD';
            pote2TextArea.value = config.pote2 || '1\n2\n3\n4';
            quadrasInput.value = config.quadras || 1;
        } else {
            // Se não há config salva, reseta para o estado inicial padrão
            resetApplicationState(false); 
        }

        if (savedFixedDuos) {
            fixedDuosMap = JSON.parse(savedFixedDuos);
        }

        if (savedGames) {
            generatedGames = JSON.parse(savedGames);
            displayGames(generatedGames);
            updateClassification(); // Não mostra pop-up de campeão no load inicial
            tabButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector('button[data-tab="jogos"]').classList.add('active');
            sections.forEach(sec => {
                if (sec.id === 'jogos') sec.classList.add('active');
                else sec.classList.remove('active');
            });
            // Habilita/desabilita campos de texto e botão de sortear
            setConfigurationFieldsDisabled(true); 
            // Os rádios de modo são desabilitados APENAS se o modo está "travado"
            radiosModo.forEach(radio => radio.disabled = modeLocked);

        } else {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector('button[data-tab="config"]').classList.add('active');
            sections.forEach(sec => {
                if (sec.id === 'config') sec.classList.add('active');
                else sec.classList.remove('active');
            });
            setConfigurationFieldsDisabled(false);
            // Garante que os radios estejam habilitados se não há jogos salvos
            radiosModo.forEach(radio => radio.disabled = false);
        }
        updateQuadrasInputLimits(); 
    }

    /**
     * Embaralha um array (Fisher-Yates shuffle).
     * @param {Array} array - O array a ser embaralhado.
     */
    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    /**
     * Normaliza a entrada de texto de jogadores/potes para um array limpo de strings.
     * Remove espaços em branco extras e linhas vazias.
     * @param {string} text - O texto de entrada do textarea.
     * @returns {Array<string>} Um array de nomes de jogadores.
     */
    function parsePlayerInput(text) {
        return text.split('\n')
                   .map(player => player.trim())
                   .filter(player => player !== '');
    }

    /**
     * Calcula o número máximo de quadras com base no número de jogadores.
     * 1 quadra para cada 4 jogadores (ou 2 duplas), arredondado para baixo.
     * @param {number} numPlayers - O número total de jogadores.
     * @param {string} mode - O modo de jogo ('individual' ou 'dupla').
     * @returns {number} O número máximo de quadras.
     */
    function calculateMaxQuadras(numPlayers, mode) {
        if (mode === 'dupla') {
            return Math.floor(numPlayers / 2); // Cada 2 duplas (4 jogadores) podem jogar em 1 quadra
        } else { // Individual
            return Math.floor(numPlayers / 4); // Cada 4 jogadores formam um jogo, usando 1 quadra
        }
    }

    /**
     * Atualiza os limites (min/max) do input de quadras e exibe uma mensagem.
     */
    function updateQuadrasInputLimits() {
        let playersCount = 0;
        let modeForCalculation = 'individual'; 

        if (currentMode.includes('com-pote')) {
            const pote1 = parsePlayerInput(pote1TextArea.value);
            const pote2 = parsePlayerInput(pote2TextArea.value);
            
            if (currentMode.startsWith('dupla-fixa')) {
                modeForCalculation = 'dupla';
                playersCount = Math.min(pote1.length, pote2.length); 
            } else { // individual-com-pote
                playersCount = pote1.length + pote2.length;
            }
        } else {
            const players = parsePlayerInput(jogadoresTextArea.value);
            playersCount = players.length;
            if (currentMode.startsWith('dupla-fixa')) {
                modeForCalculation = 'dupla';
                playersCount = Math.ceil(players.length / 2); 
            }
        }
        
        const maxQuadras = calculateMaxQuadras(playersCount, modeForCalculation);
        
        quadrasInput.min = 1;
        quadrasInput.max = Math.max(1, maxQuadras); 

        quadrasInfoSpan.textContent = `(Máximo ${quadrasInput.max} quadra${quadrasInput.max > 1 ? 's' : ''})`;

        if (parseInt(quadrasInput.value) > quadrasInput.max) {
            quadrasInput.value = quadrasInput.max;
        }
    }

    /**
     * Habilita ou desabilita os campos de configuração.
     * @param {boolean} disabled - True para desabilitar, False para habilitar.
     */
    function setConfigurationFieldsDisabled(disabled) {
        // Os radios de modo de jogo são controlados diretamente no loadGameState
        // radiosModo.forEach(radio => radio.disabled = disabled); 
        jogadoresTextArea.disabled = disabled;
        pote1TextArea.disabled = disabled;
        pote2TextArea.disabled = disabled;
        quadrasInput.disabled = disabled;
        btnSortear.disabled = disabled; // Desabilita o botão de sortear também
        
        // Esconde as opções de pote se estiver desabilitado
        if (disabled) {
            poteOptionsDiv.style.display = 'none';
        }
    }

    // --- Funções de Geração de Jogos ---

    /**
     * Gera todos os jogos possíveis para o modo "Individual sem Pote" usando Round-Robin
     * e os distribui sequencialmente pelas quadras disponíveis.
     * Garante que todos os jogos sejam gerados, independentemente do número de quadras,
     * e os atribui a rodadas e quadras de forma sequential.
     * @param {Array<string>} players - Lista de nomes dos jogadores.
     * @returns {Array<Object>} Lista de jogos gerados com rodada e quadra atribuídas.
     */
    function generateGamesIndividualNoPot(players) {
        let allPlayers = [...players];
        const n = allPlayers.length;

        if (n < 4) {
            alert("Para o modo 'Individual sem pote', você precisa de pelo menos 4 jogadores para formar duplas.");
            return [];
        }

        let tempPlayers = [...allPlayers];
        let effectiveN = n;
        
        if (effectiveN % 2 !== 0) {
            tempPlayers.push('Livre');
            effectiveN++;
        }

        const numRoundsTheoretical = effectiveN - 1; // Número de rodadas teóricas do Round-Robin
        let allPotentialGames = [];

        for (let r = 0; r < numRoundsTheoretical; r++) {
            let roundDuos = [];
            const fixedPlayer = tempPlayers[0];
            const rotatingPlayers = tempPlayers.slice(1);

            for (let i = 0; i < effectiveN / 2; i++) {
                let p1, p2;
                if (i === 0) {
                    p1 = fixedPlayer;
                    p2 = rotatingPlayers[rotatingPlayers.length - 1 - i];
                } else {
                    p1 = rotatingPlayers[i - 1];
                    p2 = rotatingPlayers[rotatingPlayers.length - 1 - i];
                }
                roundDuos.push([p1, p2]);
            }
            
            shuffle(roundDuos); // Embaralha as duplas dentro da rodada

            const playableDuos = roundDuos.filter(duo => !duo.includes('Livre'));
            for (let i = 0; i < playableDuos.length; i += 2) {
                if (i + 1 < playableDuos.length) {
                    allPotentialGames.push({
                        duplaA: playableDuos[i],
                        duplaB: playableDuos[i + 1]
                    });
                }
            }

            const lastPlayer = rotatingPlayers.pop();
            rotatingPlayers.unshift(lastPlayer);
            tempPlayers = [fixedPlayer, ...rotatingPlayers];
        }

        // Agora, distribua todos os jogos potenciais pelas quadras sequencialmente
        let finalGames = [];
        const numQuadras = parseInt(quadrasInput.value);
        let currentRound = 1;
        let currentQuadra = 1;

        allPotentialGames.forEach(game => {
            finalGames.push({
                ...game,
                rodada: currentRound,
                quadra: currentQuadra
            });

            currentQuadra++;
            if (currentQuadra > numQuadras) {
                currentQuadra = 1;
                currentRound++; // Avança para a próxima "mini-rodada" quando todas as quadras foram usadas
            }
        });
        
        return finalGames;
    }

    /**
     * Gera jogos para o modo "Individual com Pote", garantindo que cada dupla PoteA-PoteB
     * seja única ao longo de todo o torneio, e que cada jogo tenha 4 jogadores únicos.
     * Tenta encontrar uma solução que balanceie os jogos entre os jogadores, priorizando quem jogou menos recentemente.
     * Prioriza a variação nas duplas adversárias.
     * @param {Array<string>} pote1 - Jogadores do Pote 1.
     * @param {Array<string>} pote2 - Jogadores do Pote 2.
     * @returns {Array<Object>} Lista de jogos gerados.
     */
    function generateGamesIndividualWithPot(pote1, pote2) {
        const numPote1 = pote1.length;
        const numPote2 = pote2.length;
        const numQuadras = parseInt(quadrasInput.value);

        if (numPote1 < 2 || numPote2 < 2) {
            alert("Para o modo 'Individual com pote', você precisa de pelo menos 2 jogadores em cada pote para formar jogos válidos (dupla contra dupla).");
            return [];
        }

        let allPlayers = [...pote1, ...pote2];
        let lastPlayedRound = {};
        allPlayers.forEach(p => (lastPlayedRound[p] = -1));
        
        // Gerar todas as duplas possíveis de (Pote1, Pote2)
        let allPossibleP1P2Duos = [];
        pote1.forEach(pA => {
            pote2.forEach(pB => {
                allPossibleP1P2Duos.push([pA, pB]);
            });
        });
        
        let finalGames = [];
        let usedP1P2DuosInTournament = new Set(); // Duplas [PoteA, PoteB] que já foram usadas como parceiras
        let usedPlayerPairsAsOpponents = new Set(); // Para controlar quem já jogou contra quem

        // Helper para verificar se 4 jogadores são únicos
        const arePlayersUnique = (pA1, pB1, pA2, pB2) => {
            return new Set([pA1, pB1, pA2, pB2]).size === 4;
        };

        // Helper para verificar se duas duplas já se enfrentaram
        const haveDuosPlayedBefore = (duo1, duo2) => {
            const players = [...duo1, ...duo2].sort(); // Normaliza a ordem para comparação
            return usedPlayerPairsAsOpponents.has(players.join('|'));
        };

        // Helper para marcar duplas como adversárias
        const markDuosAsOpponents = (duo1, duo2) => {
            const players = [...duo1, ...duo2].sort();
            usedPlayerPairsAsOpponents.add(players.join('|'));
        };

        let rodadaCounter = 1;
        
        // Coleta todos os jogos possíveis antes de atribuir rodadas/quadras
        let allGeneratedGames = [];

        let safetyBreak = 0; // Para evitar loops infinitos em caso de lógicas complexas
        const MAX_ITERATIONS = 500; // Limite de iterações para encontrar jogos

        while (safetyBreak < MAX_ITERATIONS) { // Tenta gerar um número razoável de rodadas
            let gamesThisRoundAttempt = [];
            let playersUsedInCurrentAttempt = new Set(); 
            let availableP1P2Duos = allPossibleP1P2Duos.filter(duo => !usedP1P2DuosInTournament.has(duo.join('|')));
            
            shuffle(availableP1P2Duos); // Embaralha para tentar novas combinações

            // Sort by inactivity to prioritize players who haven't played recently
            availableP1P2Duos.sort((duo1, duo2) => {
                const lp1_1 = lastPlayedRound[duo1[0]];
                const lp1_2 = lastPlayedRound[duo1[1]];
                const lp2_1 = lastPlayedRound[duo2[0]];
                const lp2_2 = lastPlayedRound[duo2[1]];

                const inactivitySum1 = (rodadaCounter - lp1_1) + (rodadaCounter - lp1_2);
                const inactivitySum2 = (rodadaCounter - lp2_1) + (rodadaCounter - lp2_2);

                return inactivitySum2 - inactivitySum1; // Mais inativo primeiro
            });


            // Tentar formar os jogos para esta rodada
            for (let i = 0; i < availableP1P2Duos.length; i++) {
                const teamA = availableP1P2Duos[i];
                if (playersUsedInCurrentAttempt.has(teamA[0]) || playersUsedInCurrentAttempt.has(teamA[1])) {
                    continue;
                }

                // Inner loop para encontrar oponente para teamA
                for (let j = i + 1; j < availableP1P2Duos.length; j++) {
                    const teamB = availableP1P2Duos[j];
                    if (playersUsedInCurrentAttempt.has(teamB[0]) || playersUsedInCurrentAttempt.has(teamB[1])) {
                        continue;
                    }

                    // Verifica se os 4 jogadores são únicos
                    if (!arePlayersUnique(teamA[0], teamA[1], teamB[0], teamB[1])) {
                        continue;
                    }
                    
                    // Verifica se essa combinação de duplas já se enfrentou
                    if (haveDuosPlayedBefore(teamA, teamB)) {
                        continue;
                    }

                    // Se chegamos aqui, temos um jogo válido para esta rodada
                    gamesThisRoundAttempt.push({ duplaA: teamA, duplaB: teamB });
                    
                    playersUsedInCurrentAttempt.add(teamA[0]);
                    playersUsedInCurrentAttempt.add(teamA[1]);
                    playersUsedInCurrentAttempt.add(teamB[0]);
                    playersUsedInCurrentAttempt.add(teamB[1]);

                    // Marca as duplas e os adversários como usados imediatamente para evitar repetição nesta busca
                    usedP1P2DuosInTournament.add(teamA.join('|'));
                    usedP1P2DuosInTournament.add(teamB.join('|'));
                    markDuosAsOpponents(teamA, teamB); 
                    
                    if (gamesThisRoundAttempt.length >= numQuadras) { // Limita jogos por rodada
                        break; 
                    }
                }
                if (gamesThisRoundAttempt.length >= numQuadras) { // Limita jogos por rodada
                    break;
                }
            }
            
            if (gamesThisRoundAttempt.length === 0) {
                // Se não conseguimos formar nenhum jogo nesta tentativa, saímos
                // Isso pode acontecer se todas as combinações válidas já foram usadas
                break; 
            }

            // Adiciona os jogos encontrados para esta rodada à lista completa de jogos
            allGeneratedGames.push(...gamesThisRoundAttempt);

            // Atualiza a última rodada jogada para os jogadores que participaram
            playersUsedInCurrentAttempt.forEach(player => {
                lastPlayedRound[player] = rodadaCounter;
            });

            rodadaCounter++;
            safetyBreak++;
        }
        
        // Atribui rodada e quadra sequencialmente a TODOS os jogos gerados
        let currentAssignedRound = 1;
        let currentAssignedQuadra = 1;
        allGeneratedGames.forEach(game => {
            finalGames.push({
                ...game,
                rodada: currentAssignedRound,
                quadra: currentAssignedQuadra
            });
            currentAssignedQuadra++;
            if (currentAssignedQuadra > numQuadras) {
                currentAssignedQuadra = 1;
                currentAssignedRound++;
            }
        });

        return finalGames;
    }


    /**
     * Gera duplas fixas a partir de uma lista de jogadores.
     * Se houver um número ímpar de jogadores, o último jogador é pareado com 'Livre'.
     * Armazena as duplas geradas em fixedDuosMap para uso na classificação.
     * @param {Array<string>} players - Lista de nomes dos jogadores.
     * @returns {Array<Array<string>>} Lista de duplas fixas.
     */
    function generateFixedDuos(players) {
        const shuffledPlayers = [...players];
        shuffle(shuffledPlayers);
        let duos = [];
        fixedDuosMap = {}; // Reseta o mapa de duplas fixas
        for (let i = 0; i < shuffledPlayers.length; i += 2) {
            let duo;
            if (i + 1 < shuffledPlayers.length) {
                duo = [shuffledPlayers[i], shuffledPlayers[i + 1]].sort(); // Ordena para chave consistente
            } else {
                duo = [shuffledPlayers[i], 'Livre'].sort();
            }
            duos.push(duo);
            // Mapeia cada jogador à sua dupla (ordenada alfabeticamente)
            fixedDuosMap[duo[0]] = duo.join(' & ');
            fixedDuosMap[duo[1]] = duo.join(' & ');
        }
        return duos;
    }

    /**
     * Gera jogos para o modo "Dupla Fixa sem Pote" usando Round-Robin
     * e os distribui sequencialmente pelas quadras disponíveis.
     * @param {Array<string>} players - Lista de nomes dos jogadores para formar duplas.
     * @returns {Array<Object>} Lista de jogos gerados com rodada e quadra atribuída.
     */
    function generateGamesFixedDuoNoPot(players) {
        const fixedDuos = generateFixedDuos(players); // Gera e popula fixedDuosMap
        let allPotentialGames = [];
        const numQuadras = parseInt(quadrasInput.value);

        let tempDuos = [...fixedDuos];
        if (tempDuos.length % 2 !== 0) {
            tempDuos.push(['Livre', 'Livre']);
        }
        
        const numDuplas = tempDuos.length;
        const numRoundsTheoretical = numDuplas - 1;

        for (let r = 0; r < numRoundsTheoretical; r++) {
            let gamesInRoundTheoretical = [];
            for (let i = 0; i < numDuplas / 2; i++) {
                const duplaA = tempDuos[i];
                const duplaB = tempDuos[numDuplas - 1 - i];

                if (!duplaA.includes('Livre') && !duplaB.includes('Livre')) {
                    gamesInRoundTheoretical.push({
                        duplaA: duplaA,
                        duplaB: duplaB
                    });
                }
            }
            // Adiciona todos os jogos teóricos da rodada à lista geral
            allPotentialGames.push(...gamesInRoundTheoretical);

            const firstDuo = tempDuos[0];
            const rotatingDuos = tempDuos.slice(1);
            const lastDuo = rotatingDuos.pop();
            rotatingDuos.unshift(lastDuo);
            tempDuos = [firstDuo, ...rotatingDuos];
        }
        
        // Agora, distribua todos os jogos potenciais pelas quadras sequencialmente
        let finalGames = [];
        let currentRound = 1;
        let currentQuadra = 1;

        allPotentialGames.forEach(game => {
            finalGames.push({
                ...game,
                rodada: currentRound,
                quadra: currentQuadra
            });

            currentQuadra++;
            if (currentQuadra > numQuadras) {
                currentQuadra = 1;
                currentRound++;
            }
        });
        
        return finalGames;
    }


    /**
     * Gera duplas fixas combinando jogadores de dois potes.
     * Cada jogador do Pote 1 é pareado com um jogador do Pote 2.
     * Armazena as duplas geradas em fixedDuosMap para uso na classificação.
     * @param {Array<string>} pote1 - Jogadores do Pote 1.
     * @param {Array<string>} pote2 - Jogadores do Pote 2.
     * @returns {Array<Array<string>>} Lista de duplas fixas.
     */
    function generateFixedDuosWithPot(pote1, pote2) {
        const shuffledPot1 = [...pote1];
        const shuffledPot2 = [...pote2];
        shuffle(shuffledPot1);
        shuffle(shuffledPot2);

        let duos = [];
        fixedDuosMap = {}; // Reseta o mapa de duplas fixas
        const minLength = Math.min(shuffledPot1.length, shuffledPot2.length);

        for (let i = 0; i < minLength; i++) {
            const duo = [shuffledPot1[i], shuffledPot2[i]].sort(); // Ordena para chave consistente
            duos.push(duo);
            // Mapeia cada jogador à sua dupla (ordenada alfabeticamente)
            fixedDuosMap[duo[0]] = duo.join(' & ');
            fixedDuosMap[duo[1]] = duo.join(' & ');
        }
        return duos;
    }

    /**
     * Gera todos os jogos possíveis para o modo "Dupla Fixa com Pote" usando Round-Robin
     * e os distribui sequencialmente pelas quadras disponíveis.
     * @param {Array<string>} pote1 - Jogadores do Pote 1.
     * @param {Array<string>} pote2 - Jogadores do Pote 2.
     * @returns {Array<Object>} Lista de jogos gerados com rodada e quadra atribuída.
     */
    function generateGamesFixedDuoWithPot(pote1, pote2) {
        const fixedDuos = generateFixedDuosWithPot(pote1, pote2); // Gera e popula fixedDuosMap
        let allPotentialGames = [];
        const numQuadras = parseInt(quadrasInput.value);

        let tempDuos = [...fixedDuos];
        if (tempDuos.length % 2 !== 0) {
            tempDuos.push(['Livre', 'Livre']);
        }
        
        const numDuplas = tempDuos.length;
        const numRoundsTheoretical = numDuplas - 1;

        for (let r = 0; r < numRoundsTheoretical; r++) {
            let gamesInRoundTheoretical = [];
            for (let i = 0; i < numDuplas / 2; i++) {
                const duplaA = tempDuos[i];
                const duplaB = tempDuos[numDuplas - 1 - i];

                if (!duplaA.includes('Livre') && !duplaB.includes('Livre')) {
                    gamesInRoundTheoretical.push({
                        duplaA: duplaA,
                        duplaB: duplaB
                    });
                }
            }
            // Adiciona todos os jogos teóricos da rodada à lista geral
            allPotentialGames.push(...gamesInRoundTheoretical);

            const firstDuo = tempDuos[0];
            const rotatingDuos = tempDuos.slice(1);
            const lastDuo = rotatingDuos.pop();
            rotatingDuos.unshift(lastDuo);
            tempDuos = [firstDuo, ...rotatingDuos];
        }
        
        // Agora, distribua todos os jogos potenciais pelas quadras sequencialmente
        let finalGames = [];
        let currentRound = 1;
        let currentQuadra = 1;

        allPotentialGames.forEach(game => {
            finalGames.push({
                ...game,
                rodada: currentRound,
                quadra: currentQuadra
            });

            currentQuadra++;
            if (currentQuadra > numQuadras) {
                currentQuadra = 1;
                currentRound++;
            }
        });
        
        return finalGames;
    }

    // --- Funções de Exibição e Gerenciamento ---

    /**
     * Exibe os jogos gerados na tabela da aba "Jogos", utilizando as propriedades 'rodada' e 'quadra'
     * já definidas na geração dos jogos.
     * @param {Array<Object>} games - Lista de jogos a serem exibidos.
     */
    function displayGames(games) { 
        tabelaJogosBody.innerHTML = ''; // Limpa a tabela

        if (games.length === 0) {
            tabelaJogosBody.innerHTML = '<tr><td colspan="5">Nenhum jogo gerado. Verifique os jogadores e o modo de jogo.</td></tr>';
            return;
        }

        games.forEach((game, i) => {
            const row = document.createElement('tr');

            const roundCell = document.createElement('td');
            roundCell.classList.add('col-rodada'); // Adiciona a classe
            roundCell.textContent = game.rodada; 
            row.appendChild(roundCell);

            const courtCell = document.createElement('td');
            courtCell.classList.add('col-quadra'); // Adiciona a classe
            courtCell.textContent = game.quadra; 
            row.appendChild(courtCell);

            const teamACell = document.createElement('td');
            teamACell.textContent = Array.isArray(game.duplaA) ? game.duplaA.join(' & ') : game.duplaA;
            row.appendChild(teamACell);
            
            const resultCell = document.createElement('td'); // Célula do resultado
            const isTeamALibre = Array.isArray(game.duplaA) && game.duplaA.includes('Livre');
            const isTeamBLibre = Array.isArray(game.duplaB) && game.duplaB.includes('Livre');

            if (!isTeamALibre && !isTeamBLibre) {
                const inputA = document.createElement('input');
                inputA.type = 'number';
                inputA.min = 0;
                inputA.className = 'result-input';
                inputA.dataset.gameIndex = i; 
                inputA.dataset.team = 'A';
                if (game.gamesDuplaA !== undefined) inputA.value = game.gamesDuplaA;

                const inputB = document.createElement('input');
                inputB.type = 'number';
                inputB.min = 0;
                inputB.className = 'result-input';
                inputB.dataset.gameIndex = i; 
                inputB.dataset.team = 'B';
                if (game.gamesDuplaB !== undefined) inputB.value = game.gamesDuplaB;

                inputA.addEventListener('change', updateResult);
                inputB.addEventListener('change', updateResult);

                resultCell.appendChild(inputA);
                resultCell.appendChild(document.createTextNode(' x '));
                resultCell.appendChild(inputB);
            } else {
                resultCell.textContent = '-';
            }
            row.appendChild(resultCell); // Adiciona a célula de resultado

            const teamBCell = document.createElement('td');
            teamBCell.textContent = Array.isArray(game.duplaB) ? game.duplaB.join(' & ') : game.duplaB;
            row.appendChild(teamBCell);

            tabelaJogosBody.appendChild(row);
        });
    }

    /**
     * Atualiza o resultado de um jogo no array `generatedGames`, recalcula a classificação
     * e salva o estado do jogo.
     * @param {Event} event - O evento de mudança do input de resultado.
     */
    function updateResult(event) {
        const input = event.target;
        const gameIndex = parseInt(input.dataset.gameIndex);
        const team = input.dataset.team;
        const value = parseInt(input.value);

        if (isNaN(value) || value < 0) {
            alert('Por favor, insira um valor válido (0 ou mais) para os games.');
            input.value = '';
            return;
        }

        if (generatedGames[gameIndex]) {
            generatedGames[gameIndex][`gamesDupla${team}`] = value;
        }
        updateClassification(); // Não mostra pop-up de campeão ao atualizar resultado individualmente
        saveGameState(); // Salva o estado após cada atualização de resultado
    }

    /**
     * Normaliza um array de jogadores (dupla) para uma chave consistente (string).
     * Ex: ['Pedro', 'Lucas'] vira 'Lucas & Pedro'
     * @param {Array<string>} playersArray - Array de jogadores.
     * @returns {string} Chave normalizada.
     */
    function normalizeDuoName(playersArray) {
        if (!Array.isArray(playersArray) || playersArray.length === 0) {
            return '';
        }
        const filteredPlayers = playersArray.filter(p => p !== 'Livre');
        if (filteredPlayers.length === 0) {
            return 'Livre & Livre'; // Caso ambas sejam 'Livre'
        }
        return filteredPlayers.sort().join(' & ');
    }

    /**
     * Compara duas estatísticas para determinar se são idênticas para fins de empate.
     * @param {Object} stats1 - Objeto de estatísticas do primeiro jogador/dupla.
     * @param {Object} stats2 - Objeto de estatísticas do segundo jogador/dupla.
     * @param {boolean} isFixedDuoMode - Indica se está no modo de dupla fixa.
     * @returns {boolean} True se as estatísticas são idênticas, False caso contrário.
     */
    function areStatsIdentical(stats1, stats2, isFixedDuoMode) {
        // Primeira verificação para evitar undefined se stats2 for null/undefined
        if (!stats1 || !stats2) return false;

        if (stats1.wins !== stats2.wins) return false;
        if (stats1.gamesBalance !== stats2.gamesBalance) return false;

        // Para o confronto direto, precisamos verificar a relação mútua
        const name1 = stats1.name; // Já é o nome do jogador ou da dupla normalizado
        const name2 = stats2.name; // Já é o nome do jogador ou da dupla normalizado

        // Garante que a propriedade headToHead exista antes de tentar acessá-la
        const h2h1_vs_2 = (stats1.headToHead && stats1.headToHead[name2]) ? stats1.headToHead[name2] : 0;
        const h2h2_vs_1 = (stats2.headToHead && stats2.headToHead[name1]) ? stats2.headToHead[name1] : 0;

        return h2h1_vs_2 === h2h2_vs_1; // Se o número de vitórias diretas for igual, eles estão empatados no H2H
    }

    /**
     * Atualiza a tabela de classificação na aba "Resultado" com base nos jogos registrados.
     * Adapta a exibição para duplas ou jogadores individuais.
     * @param {boolean} showChampionPopup - Se true, exibe o pop-up do campeão após a classificação.
     */
    function updateClassification(showChampionPopup = false) {
        tabelaResultadoBody.innerHTML = '';

        const isFixedDuoMode = currentMode.startsWith('dupla-fixa');

        // Ajusta o cabeçalho da tabela de resultados
        headerName.textContent = isFixedDuoMode ? 'Dupla' : 'Jogador';

        let sortedEntities = []; // Pode ser sortedDuos ou playersArray

        if (isFixedDuoMode) {
            // Lógica para classificação por duplas fixas
            const duoStats = {};

            // Inicializa estatísticas para cada dupla fixa
            // Obter duplas únicas a partir de 'generatedGames' ou de 'fixedDuosMap' se não houver jogos
            const uniqueDuosInGames = new Set();
            generatedGames.forEach(game => {
                const duoA = normalizeDuoName(game.duplaA);
                const duoB = normalizeDuoName(game.duplaB);
                if (duoA && duoA !== 'Livre & Livre') uniqueDuosInGames.add(duoA);
                if (duoB && duoB !== 'Livre & Livre') uniqueDuosInGames.add(duoB);
            });
            // Adiciona duplas do fixedDuosMap que podem não ter jogado ainda
            Object.values(fixedDuosMap).forEach(duoName => {
                if (duoName && duoName !== 'Livre & Livre') uniqueDuosInGames.add(duoName);
            });


            uniqueDuosInGames.forEach(duoName => {
                if (!duoStats[duoName]) {
                    duoStats[duoName] = {
                        name: duoName,
                        wins: 0,
                        losses: 0,
                        gamesWon: 0,
                        gamesLost: 0,
                        gamesBalance: 0,
                        headToHead: {} // Para armazenar vitórias diretas contra outras duplas
                    };
                }
            });

            generatedGames.forEach(game => {
                if (game.gamesDuplaA == null || game.gamesDuplaB == null) return;

                const duoA = normalizeDuoName(game.duplaA);
                const duoB = normalizeDuoName(game.duplaB);
                
                if (duoA === 'Livre & Livre' || duoB === 'Livre & Livre' || !duoStats[duoA] || !duoStats[duoB]) {
                    return; // Ignora jogos com duplas "Livre" ou duplas não mapeadas (o que não deveria acontecer se uniqueDuosInGames estiver correto)
                }

                const gamesA = game.gamesDuplaA;
                const gamesB = game.gamesDuplaB;

                duoStats[duoA].gamesWon += gamesA;
                duoStats[duoA].gamesLost += gamesB;
                duoStats[duoB].gamesWon += gamesB;
                duoStats[duoB].gamesLost += gamesA;

                if (gamesA > gamesB) {
                    duoStats[duoA].wins++;
                    duoStats[duoB].losses++;
                    // Registrar vitória no confronto direto
                    if (!duoStats[duoA].headToHead[duoB]) duoStats[duoA].headToHead[duoB] = 0;
                    duoStats[duoA].headToHead[duoB]++;
                } else if (gamesB > gamesA) {
                    duoStats[duoB].wins++;
                    duoStats[duoA].losses++;
                    // Registrar vitória no confronto direto
                    if (!duoStats[duoB].headToHead[duoA]) duoStats[duoB].headToHead[duoA] = 0;
                    duoStats[duoB].headToHead[duoA]++;
                }
            });

            // Calcula saldo de games para todas as duplas antes da ordenação
            Object.values(duoStats).forEach(stats => {
                stats.gamesBalance = stats.gamesWon - stats.gamesLost;
            });

            // Ordena as duplas
            sortedEntities = Object.values(duoStats)
                                    .filter(duo => duo.name !== "Livre & Livre") // Remove a dupla "Livre & Livre"
                                    .sort((a, b) => {
                // 1. Vitórias (maior para menor)
                if (b.wins !== a.wins) return b.wins - a.wins;
                
                // 2. Saldo de Games (maior para menor)
                if (b.gamesBalance !== a.gamesBalance) return b.gamesBalance - a.gamesBalance;

                // 3. Critério de desempate: Confronto Direto entre Duplas
                // 'a' venceu 'b' mais vezes? Se sim, 'a' vem antes (positivo)
                // 'b' venceu 'a' mais vezes? Se sim, 'b' vem antes (negativo)
                // Usamos `|| 0` para garantir que se a propriedade não existir, seja tratada como 0
                const h2hDiff = (a.headToHead[b.name] || 0) - (b.headToHead[a.name] || 0);
                if (h2hDiff !== 0) {
                    return h2hDiff > 0 ? -1 : 1; // Coloca quem ganhou o confronto direto na frente
                }

                return 0; // Se tudo igual, mantém a ordem original (ou alfabética, etc.)
            });

        } else {
            // Lógica para classificação individual
            const uniquePlayers = new Set();
            generatedGames.forEach(game => {
                const teamA = Array.isArray(game.duplaA) ? game.duplaA.filter(p => p !== 'Livre') : (game.duplaA === 'Livre' ? [] : [game.duplaA]);
                const teamB = Array.isArray(game.duplaB) ? game.duplaB.filter(p => p !== 'Livre') : (game.duplaB === 'Livre' ? [] : [game.duplaB]);

                teamA.forEach(p => uniquePlayers.add(p));
                teamB.forEach(p => uniquePlayers.add(p));
            });
            // Adiciona jogadores da área de texto de configuração que podem não ter jogado ainda
            const allConfigPlayers = parsePlayerInput(jogadoresTextArea.value);
            allConfigPlayers.forEach(p => uniquePlayers.add(p));


            const playersArray = Array.from(uniquePlayers);

            const playerStats = {};
            playersArray.forEach(player => {
                if (player !== 'Livre') { // Garante que 'Livre' não seja adicionado como um jogador
                    playerStats[player] = {
                        name: player,
                        wins: 0,
                        losses: 0,
                        gamesWon: 0,
                        gamesLost: 0,
                        gamesBalance: 0,
                        headToHead: {} // Para armazenar vitórias diretas contra outros jogadores
                    };
                }
            });

            generatedGames.forEach(game => {
                if (game.gamesDuplaA == null || game.gamesDuplaB == null) return;

                const teamA = Array.isArray(game.duplaA) ? game.duplaA.filter(p => p !== 'Livre') : (game.duplaA === 'Livre' ? [] : [game.duplaA]);
                const teamB = Array.isArray(game.duplaB) ? game.duplaB.filter(p => p !== 'Livre') : (game.duplaB === 'Livre' ? [] : [game.duplaB]);

                if (teamA.length === 0 || teamB.length === 0) return; // Se uma dupla é "Livre" ou está vazia

                const gamesA = game.gamesDuplaA;
                const gamesB = game.gamesDuplaB;

                teamA.forEach(player => {
                    if (playerStats[player]) {
                        playerStats[player].gamesWon += gamesA;
                        playerStats[player].gamesLost += gamesB;
                    }
                });
                teamB.forEach(player => {
                    if (playerStats[player]) {
                        playerStats[player].gamesWon += gamesB;
                        playerStats[player].gamesLost += gamesA;
                    }
                });

                if (gamesA > gamesB) {
                    teamA.forEach(player => { if (playerStats[player]) playerStats[player].wins++; });
                    teamB.forEach(player => { if (playerStats[player]) playerStats[player].losses++; });
                } else if (gamesB > gamesA) {
                    teamB.forEach(player => { if (playerStats[player]) playerStats[player].wins++; });
                    teamA.forEach(player => { if (playerStats[player]) playerStats[player].losses++; });
                }

                // Registro de confronto direto entre cada par de jogadores nas duplas
                teamA.forEach(pA => {
                    teamB.forEach(pB => {
                        if (playerStats[pA] && playerStats[pB]) {
                            // Inicializa o headToHead se não existir
                            if (!playerStats[pA].headToHead[pB]) playerStats[pA].headToHead[pB] = 0;
                            if (!playerStats[pB].headToHead[pA]) playerStats[pB].headToHead[pA] = 0;

                            if (gamesA > gamesB) playerStats[pA].headToHead[pB]++;
                            else if (gamesB > gamesA) playerStats[pB].headToHead[pA]++;
                        }
                    });
                });
            });

            // Calcula saldo de games para todos os jogadores antes da ordenação
            playersArray.forEach(player => {
                if (playerStats[player] && player !== 'Livre') {
                    playerStats[player].gamesBalance = playerStats[player].gamesWon - playerStats[player].gamesLost;
                }
            });

            sortedEntities = playersArray
                                .filter(player => playerStats[player] && player !== 'Livre') // Remove 'Livre' e jogadores sem stats
                                .sort((a, b) => {
                const statsA = playerStats[a];
                const statsB = playerStats[b];

                // 1. Vitórias (maior para menor)
                if (statsB.wins !== statsA.wins) return statsB.wins - statsA.wins;
                // 2. Saldo de Games (maior para menor)
                if (statsB.gamesBalance !== statsA.gamesBalance) return statsB.gamesBalance - statsA.gamesBalance;
                
                // 3. Confronto Direto
                const h2hDiff = (statsA.headToHead[b] || 0) - (statsB.headToHead[a] || 0);
                if (h2hDiff !== 0) {
                     return h2hDiff > 0 ? -1 : 1; // Coloca quem ganhou o confronto direto na frente
                }
                
                return 0; // Se tudo igual, mantém a ordem original (ou alfabética, etc.)
            });
        }

        // --- Lógica para exibir Posição com empates ---
        let currentRank = 1;
        let previousEntityStats = null; // Inicializa como null

        sortedEntities.forEach((stats, index) => {
            let displayRank = currentRank;

            // Só compara com o anterior se não for o primeiro elemento
            if (index > 0) {
                // `previousEntityStats` já foi definido na iteração anterior
                if (areStatsIdentical(stats, previousEntityStats, isFixedDuoMode)) {
                    displayRank = currentRank; // Mantém a mesma posição
                } else {
                    currentRank = index + 1; // A próxima posição é o índice atual + 1
                    displayRank = currentRank;
                }
            }
            
            // Atualiza o previousEntityStats para a próxima iteração
            previousEntityStats = stats; 

            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${displayRank}</td>
                <td>${stats.name}</td>
                <td>${stats.wins}</td>
                <td>${stats.losses}</td>
                <td>${stats.gamesBalance}</td>
                <td>${stats.gamesWon}</td>
                <td>${stats.gamesLost}</td>
            `;
            tabelaResultadoBody.appendChild(row);
        });

        // --- Lógica para o Pop-up de Campeão/Empate ---
        if (showChampionPopup && sortedEntities.length > 0) {
            const topRanked = sortedEntities[0];
            const champions = [topRanked.name];
            let tieCount = 1;

            for (let i = 1; i < sortedEntities.length; i++) {
                if (areStatsIdentical(topRanked, sortedEntities[i], isFixedDuoMode)) {
                    champions.push(sortedEntities[i].name);
                    tieCount++;
                } else {
                    break; // Parar de contar assim que as estatísticas diferem
                }
            }

            let title = '';
            let message = '';

            if (tieCount === 1) {
                title = `Campeão${isFixedDuoMode ? ' da Dupla' : ''}!`;
                message = `O campeão é: <strong>${champions[0]}</strong>!`;
            } else if (tieCount === 2) {
                title = `Empate Duplo!`;
                message = `Houve um empate em 1º lugar entre: <br><strong>${champions.join(' e ')}</strong>.`;
            } else {
                title = `Empate Múltiplo!`;
                message = `Houve um empate em 1º lugar entre ${tieCount} ${isFixedDuoMode ? 'duplas' : 'jogadores'}: <br><strong>${champions.join(', ')}</strong>.`;
            }
            showPopup(title, message);
        }
    }

    /**
     * Reseta o estado da aplicação, limpando campos, tabelas e variáveis globais.
     * @param {boolean} clearLocalStorage - Se true, limpa também os dados do localStorage.
     */
    function resetApplicationState(clearLocalStorage = true) {
        jogadoresTextArea.value = 'Lucas\nMaria\nPedro\nAna\nJoão\nCarla\nPaulo\nMarina';
        pote1TextArea.value = 'A\nB\nC\nD'; 
        pote2TextArea.value = '1\n2\n3\n4';
        generatedGames = [];
        fixedDuosMap = {}; // Limpa o mapa de duplas fixas
        poteOptionsDiv.style.display = 'none';
        playerActionInfoDiv.style.display = 'none';
        updateClassification(); // Atualiza a classificação para limpar a tabela (sem pop-up)
        tabelaJogosBody.innerHTML = '';
        quadrasInput.value = 1; 
        updateQuadrasInputLimits(); 
        setConfigurationFieldsDisabled(false); // Habilita os campos de texto e botão sortear
        
        // Garante que os radios estejam habilitados e o modo "individual-sem-pote" esteja selecionado ao reiniciar
        radiosModo.forEach(radio => radio.disabled = false);
        document.querySelector('input[name="modo"][value="individual-sem-pote"]').checked = true;
        campoComPote.style.display = 'none';
        campoSemPote.style.display = 'block';
        currentMode = 'individual-sem-pote';

        if (clearLocalStorage) {
            localStorage.removeItem(LOCAL_STORAGE_KEY_GAMES);
            localStorage.removeItem(LOCAL_STORAGE_KEY_CONFIG);
            localStorage.removeItem(LOCAL_STORAGE_KEY_MODE_LOCKED); 
            localStorage.removeItem(LOCAL_STORAGE_KEY_FIXED_DUOS); // Remove a chave das duplas fixas
        }
    }

    // --- Event Listeners para Botões de Ação de Potes Desbalanceados ---

    document.getElementById('btnExcludePlayer').addEventListener('click', () => {
        let pote1 = parsePlayerInput(pote1TextArea.value);
        let pote2 = parsePlayerInput(pote2TextArea.value);

        let largerPoteRef;
        let largerPoteName; 
        if (pote1.length > pote2.length) {
            largerPoteRef = pote1;
            largerPoteName = "Pote 1";
        } else if (pote2.length > pote1.length) {
            largerPoteRef = pote2;
            largerPoteName = "Pote 2";
        } else {
            alert('Os potes já estão balanceados. Não há jogador para excluir.');
            poteOptionsDiv.style.display = 'none';
            return;
        }
        
        const randomIndex = Math.floor(Math.random() * largerPoteRef.length);
        const excludedPlayer = largerPoteRef.splice(randomIndex, 1)[0];
        
        playerActionInfoDiv.innerHTML = `Jogador <span class="player-highlight">${excludedPlayer}</span> foi excluído do ${largerPoteName}.`;
        playerActionInfoDiv.style.display = 'block';

        pote1TextArea.value = pote1.join('\n');
        pote2TextArea.value = pote2.join('\n');

        poteOptionsDiv.style.display = 'none';
        updateQuadrasInputLimits(); 
        handleSortGames();
    });

    document.getElementById('btnMovePlayer').addEventListener('click', () => {
        let pote1 = parsePlayerInput(pote1TextArea.value);
        let pote2 = parsePlayerInput(pote2TextArea.value);

        let largerPoteRef, smallerPoteRef;
        let largerPoteName, smallerPoteName; 
        if (pote1.length > pote2.length) {
            largerPoteRef = pote1;
            smallerPoteRef = pote2;
            largerPoteName = "Pote 1";
            smallerPoteName = "Pote 2";
        } else if (pote2.length > pote1.length) {
            largerPoteRef = pote2;
            smallerPoteRef = pote1;
            largerPoteName = "Pote 2";
            smallerPoteName = "Pote 1";
        } else {
            alert('Os potes já estão balanceados. Não há jogador para mover.');
            poteOptionsDiv.style.display = 'none';
            return;
        }

        if (Math.abs(largerPoteRef.length - smallerPoteRef.length) === 2) {
            const randomIndex = Math.floor(Math.random() * largerPoteRef.length);
            const movedPlayer = largerPoteRef.splice(randomIndex, 1)[0];
            smallerPoteRef.push(movedPlayer);

            playerActionInfoDiv.innerHTML = `Jogador <span class="player-highlight">${movedPlayer}</span> foi movido do ${largerPoteName} para o ${smallerPoteName}.`;
            playerActionInfoDiv.style.display = 'block';

            pote1TextArea.value = pote1.join('\n');
            pote2TextArea.value = pote2.join('\n');

            poteOptionsDiv.style.display = 'none';
            updateQuadrasInputLimits(); 
            handleSortGames();
        } else {
            alert("Não é possível balancear os potes para tamanhos iguais movendo apenas um jogador. Considere excluir.");
        }
    });

    // --- Função Principal para Iniciar o Sorteio ---

    function handleSortGames() {
        currentMode = document.querySelector('input[name="modo"]:checked').value;
        const selectedQuadras = parseInt(quadrasInput.value);

        if (currentMode.includes('com-pote')) {
            let pote1 = parsePlayerInput(pote1TextArea.value);
            let pote2 = parsePlayerInput(pote2TextArea.value);

            if (pote1.length === 0 || pote2.length === 0) {
                alert('Por favor, preencha ambos os potes para o modo com pote.');
                return;
            }

            // Apenas verifica balanceamento se o modo é Dupla Fixa com Pote
            if (currentMode === 'dupla-fixa-com-pote' && pote1.length !== pote2.length) {
                poteOptionsDiv.style.display = 'block';
                playerActionInfoDiv.style.display = 'none';
                
                // Habilita ou desabilita o botão "Mover" com base na possibilidade de balancear
                // Considera que pode mover apenas se a diferença for 2 (ex: 4 e 6 -> vira 5 e 5)
                if (Math.abs(pote1.length - pote2.length) === 2) {
                    btnMovePlayer.style.display = 'inline-block';
                } else {
                    btnMovePlayer.style.display = 'none';
                }
                alert('Para o modo "Dupla Fixa com Pote", os potes devem ter o mesmo número de jogadores. Por favor, escolha uma ação para balanceá-los.');
                return;
            } else {
                poteOptionsDiv.style.display = 'none';
                playerActionInfoDiv.style.display = 'none';
            }

            if (currentMode === 'individual-com-pote') {
                generatedGames = generateGamesIndividualWithPot(pote1, pote2);
            } else { // dupla-fixa-com-pote
                generatedGames = generateGamesFixedDuoWithPot(pote1, pote2);
            }

        } else { // Modos sem pote
            const players = parsePlayerInput(jogadoresTextArea.value);
            if (players.length < 4) {
                alert('Por favor, insira pelo menos 4 jogadores para os modos individuais e de dupla fixa sem pote.');
                return generatedGames = []; 
            }

            if (currentMode === 'individual-sem-pote') {
                generatedGames = generateGamesIndividualNoPot(players);
            } else { // dupla-fixa-sem-pote
                generatedGames = generateGamesFixedDuoNoPot(players); 
            }
        }

        if (generatedGames.length === 0) {
            alert("Não foi possível gerar jogos com as configurações atuais. Verifique o número de jogadores e o modo de jogo.");
            return;
        }
        
        displayGames(generatedGames); 
        updateClassification(); // Não mostra pop-up de campeão no sorteio inicial
        saveGameState(); 
        setConfigurationFieldsDisabled(true); 
        // Trava os radios de modo após o sorteio
        radiosModo.forEach(radio => radio.disabled = true);
        
        // showPopup('Sorteio Realizado!', 'Os jogos foram criados com sucesso.'); // Pop-up de sorteio REMOVIDO AQUI
    }

    // --- Associações de Eventos ---
    document.getElementById('btnSortear').addEventListener('click', handleSortGames);

    document.getElementById('btnReiniciar').addEventListener('click', () => {
        if (confirm('Tem certeza que deseja reiniciar e apagar todas as informações?')) {
            resetApplicationState(true); 
            tabButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector('button[data-tab="config"]').classList.add('active');
            sections.forEach(sec => {
                if (sec.id === 'config') sec.classList.add('active');
                else sec.classList.remove('active');
            });
        }
    });

    // Carrega o estado do jogo ao carregar a página
    window.addEventListener('load', loadGameState);

</script>

</body>
</html>
