<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Super 8 - Beach Tennis</title>
<style>
    /* Reset básico e box-sizing para melhor responsividade */
    html {
        box-sizing: border-box;
    }
    *, *::before, *::after {
        box-sizing: inherit;
    }

    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      margin: 0; padding: 0; background: #f0f2f5; color: #333;
      display: flex;
      flex-direction: column; /* Organiza itens em coluna */
      min-height: 100vh; /* Garante que o body ocupe a altura total da tela */
    }
    header {
      background: #2980b9; color: white; padding: 1rem; text-align: center;
      font-weight: 700; font-size: 1.4rem;
    }
    main {
      max-width: 900px; /* Largura máxima fixa para evitar redimensionamento */
      width: 100%; /* Garante que ocupe a largura total dentro do max-width */
      margin: 1rem auto; /* Centraliza o main */
      background: white; border-radius: 8px; box-shadow: 0 0 10px rgb(0 0 0 / 0.1);
      padding: 1rem 2rem 2rem 2rem;
      flex-grow: 1; /* Garante que o main ocupe o espaço restante */
    }
    nav {
      display: flex; border-bottom: 2px solid #2980b9; margin-bottom: 1rem;
    }
    nav button {
      flex: 1; background: transparent; border: none; padding: 1rem; font-size: 1rem; cursor: pointer; font-weight: 600; color: #2980b9;
      border-bottom: 3px solid transparent; transition: 0.3s ease;
    }
    nav button.active {
      border-bottom-color: #2980b9; color: #145a86;
    }
    section {
      display: none;
    }
    section.active {
      display: block;
    }
    label {
      display: block; margin-top: 0.8rem; font-weight: 600;
    }
    textarea, input[type=text] {
      width: 100%; padding: 8px; margin-top: 0.3rem; border-radius: 4px; border: 1px solid #ccc; font-size: 1rem;
    }
    textarea {
      resize: vertical;
    }
    fieldset {
      border: 1px solid #ccc; border-radius: 5px; padding: 10px 15px 15px 15px; margin-top: 1rem;
    }
    legend {
      font-weight: 700; color: #2980b9; padding: 0 6px;
    }
    button.action-btn {
      background: #2980b9; color: white; border: none; padding: 10px 20px; margin-top: 15px; border-radius: 5px; cursor: pointer;
      font-weight: 700; margin-right: 10px; /* Espaço entre botões */
    }
    button.action-btn:hover {
      background: #1c5d86;
    }
    button.action-btn:disabled {
        background: #cccccc;
        cursor: not-allowed;
    }
    table {
      width: 100%; border-collapse: collapse; margin-top: 1rem;
    }
    th, td {
      border: 1px solid #ddd; padding: 8px; text-align: center;
    }
    th {
      background: #2980b9; color: white;
    }
    /* Novos estilos para estreitar as colunas de Rodada e Quadra */
    .col-rodada {
        width: 5%; /* Ajuste conforme necessário, mais estreito */
        min-width: 40px; /* Garante um tamanho mínimo */
    }
    .col-quadra {
        width: 5%; /* Ajuste conforme necessário, mais estreito */
        min-width: 40px; /* Garante um tamanho mínimo */
    }

    input.result-input {
      width: 50px; text-align: center; font-weight: 600; font-size: 1rem; border: 1px solid #2980b9; border-radius: 4px;
    }
    .center {
      text-align: center;
    }
    .player-highlight {
        font-weight: bold;
        color: red;
        font-size: 1.1rem;
    }
    .option-buttons {
        margin-top: 15px;
        display: flex;
        gap: 10px;
    }
    #quadrasInputContainer {
        margin-top: 15px;
    }
    #quadrasInputContainer label {
        display: inline-block; /* Para manter o label e o input na mesma linha */
        margin-right: 10px;
    }
    #quadras {
        width: auto; /* Ajusta a largura para caber o número */
        padding: 5px;
        text-align: center;
    }

    footer {
        text-align: center;
        padding: 1rem;
        background: #2980b9;
        color: white;
        margin-top: auto; /* Empurra o rodapé para baixo */
    }
    .footer-text {
        margin: 0.2rem 0; /* Espaçamento para o texto do rodapé */
        font-size: 0.9em;
    }

    .criteria-text {
        margin-top: 1rem;
        font-size: 0.9em;
        color: #555;
    }
    .criteria-list {
        margin-left: 1.5rem;
        padding-left: 0;
    }

    /* Estilos para o Fieldset de Modo de Jogo */
    fieldset:has(input[name="modo"]) {
        display: flex;
        flex-wrap: wrap; /* Permite que os itens quebrem para a próxima linha */
        gap: 10px; /* Espaço entre os itens */
        justify-content: space-between; /* Distribui os itens horizontalmente */
        align-items: center; /* Centraliza verticalmente */
    }

    fieldset:has(input[name="modo"]) label {
        display: flex; /* Para alinhar o rádio e o texto */
        align-items: center;
        margin-top: 0; /* Remove margem superior padrão */
        font-weight: normal; /* Normaliza o peso da fonte */
        flex-basis: calc(50% - 5px); /* Duas colunas por padrão */
    }

    fieldset:has(input[name="modo"]) input[type="radio"] {
        margin-right: 5px; /* Espaço entre o rádio e o texto */
    }

    /* Mensagens na página */
    .in-page-message {
        background-color: #e7f3fe; /* Light blue background */
        border-left: 6px solid #2196F3; /* Blue border */
        margin-top: 1rem;
        padding: 10px 15px;
        color: #0c5460; /* Darker blue text */
        border-radius: 4px;
        font-size: 0.95em;
        text-align: center;
    }
    .in-page-message.error {
        background-color: #f8d7da; /* Light red background */
        border-left: 6px solid #dc3545; /* Red border */
        color: #721c24; /* Darker red text */
    }

    /* Media Queries para responsividade */
    @media (max-width: 768px) { /* Tablets e telas menores */
        main {
            padding: 1rem 1.5rem; /* Ajusta padding para telas um pouco menores */
        }
        nav button {
            font-size: 0.9rem;
            padding: 0.8rem;
        }
        fieldset:has(input[name="modo"]) label {
            flex-basis: 100%; /* Uma coluna em telas menores */
        }
    }

    @media (max-width: 600px) { /* Smartphones */
        main {
            margin: 0.5rem auto;
            padding: 1rem; /* Mais ajuste de padding para telas pequenas */
        }
        header {
            font-size: 1.2rem;
            padding: 0.8rem;
        }
        nav button {
            font-size: 0.8rem;
            padding: 0.6rem;
        }
        table, th, td {
            font-size: 0.75rem; /* Reduz a fonte da tabela */
            padding: 6px;
        }
        input.result-input {
            width: 40px; /* Reduz largura dos inputs de resultado */
            font-size: 0.8rem;
        }
        button.action-btn {
            padding: 8px 15px;
            font-size: 0.9rem;
        }
        /* Ajuste para que o texto do label não quebre tão cedo no modo de jogo */
        fieldset:has(input[name="modo"]) label {
             font-size: 0.9rem; /* Reduz a fonte do texto do rádio */
        }
    }
</style>
</head>
<body>

<header>Super 8 - Beach Tennis</header>

<main>
    <nav>
        <button class="tab-button active" data-tab="config">Configuração</button>
        <button class="tab-button" data-tab="jogos">Jogos</button>
        <button class="tab-button" data-tab="resultado">Resultado</button>
    </nav>

    <section id="config" class="active">
        <fieldset>
            <legend>Modo de Jogo</legend>
            <label><input type="radio" name="modo" value="individual-sem-pote" checked> Individual sem pote</label>
            <label><input type="radio" name="modo" value="individual-com-pote"> Individual com pote</label>
            <label><input type="radio" name="modo" value="dupla-fixa-sem-pote"> Dupla fixa sem pote</label>
            <label><input type="radio" name="modo" value="dupla-fixa-com-pote"> Dupla fixa com pote</label>
        </fieldset>

        <div id="campoSemPote">
            <label for="jogadores">Jogadores (um por linha):</label>
            <textarea id="jogadores" rows="8" placeholder="Exemplo: Lucas&#10;Maria&#10;Pedro&#10;Ana"></textarea>
        </div>

        <div id="campoComPote" style="display:none;">
            <label for="pote1">Pote 1 (um por linha):</label>
            <textarea id="pote1" rows="6" placeholder="Exemplo: Lucas&#10;Pedro&#10;João&#10;Paulo"></textarea>

            <label for="pote2">Pote 2 (um por linha):</label>
            <textarea id="pote2" rows="6" placeholder="Exemplo: Maria&#10;Ana&#10;Carla&#10;Marina"></textarea>
            <div id="poteOptions" style="display:none;">
                <p>Os potes têm números de jogadores diferentes. Escolha uma opção:</p>
                <div class="option-buttons">
                    <button class="action-btn" id="btnExcludePlayer">Excluir um jogador do pote maior</button>
                    <button class="action-btn" id="btnMovePlayer" style="display:none;">Mover um jogador para o outro pote</button>
                </div>
                <div id="playerActionInfo" class="player-highlight" style="display:none;"></div>
            </div>
        </div>
        
        <div id="quadrasInputContainer">
            <label for="quadras">Quantidade de Quadras:</label>
            <input type="number" id="quadras" value="1" min="1">
            <span id="quadrasInfo" style="font-size: 0.9em; color: #555;"></span>
        </div>

        <button class="action-btn" id="btnSortear">Sortear Jogos</button>
        <button class="action-btn" id="btnReiniciar">Reiniciar</button>
    </section>

    <section id="jogos">
        <table id="tabelaJogos">
            <thead>
                <tr>
                    <th class="col-rodada">Rodada</th>
                    <th class="col-quadra">Quadra</th>
                    <th>Dupla A</th>
                    <th>Resultado (Games)</th> 
                    <th>Dupla B</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
        <div id="gameCreationMessage" class="in-page-message" style="display: none;"></div>
    </section>

    <section id="resultado">
        <table id="tabelaResultado">
            <thead>
                <tr>
                    <th>Posição</th>
                    <th id="headerName">Jogador</th> 
                    <th>Vitórias</th>
                    <th>Derrotas</th>
                    <th>Saldo de Games</th> 
                    <th>Games Ganhados</th>
                    <th>Games Perdidos</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
        <div id="championMessage" class="in-page-message" style="display: none;"></div>
        <p class="criteria-text">
            **Critérios de Desempate:**
            <ol class="criteria-list">
                <li>Maior número de **Vitórias**</li>
                <li>Maior **Saldo de Games** (Games Ganhados - Games Perdidos)</li>
                <li>Em caso de novo empate, o critério é o **Confronto Direto** (quem ganhou o jogo entre os empatados)</li>
            </ol>
        </p>
    </section>
</main>

<footer>
    <div class="footer-text">© 2025 Todos os direitos reservados. Proibida a cópia ou reprodução.</div>
    <div class="footer-text">Desenvolvido por Lauro Licce.</div>
    <div class="footer-text">v1.0.1</div>
</footer>

<script>
    // Gerenciamento de abas
    const tabButtons = document.querySelectorAll('.tab-button');
    const sections = document.querySelectorAll('main section');

    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            const targetTab = button.dataset.tab;
            sections.forEach(section => {
                if (section.id === targetTab) section.classList.add('active');
                else section.classList.remove('active');
            });
            // Quando muda para a aba de resultado, atualiza a classificação e mostra a mensagem do campeão
            if (targetTab === 'resultado') {
                updateClassification(true); // true para indicar que é uma atualização de tab
            } else {
                // Esconde as mensagens ao trocar de aba
                displayMessage('gameCreationMessage', '', false);
                displayMessage('championMessage', '', false);
            }
        });
    });

    // Referências a elementos DOM
    const radiosModo = document.querySelectorAll('input[name="modo"]');
    const campoSemPote = document.getElementById('campoSemPote');
    const campoComPote = document.getElementById('campoComPote');
    const poteOptionsDiv = document.getElementById('poteOptions');
    const playerActionInfoDiv = document.getElementById('playerActionInfo');
    const btnMovePlayer = document.getElementById('btnMovePlayer');
    const jogadoresTextArea = document.getElementById('jogadores');
    const pote1TextArea = document.getElementById('pote1');
    const pote2TextArea = document.getElementById('pote2');
    const tabelaJogosBody = document.querySelector('#tabelaJogos tbody');
    const tabelaResultadoBody = document.querySelector('#tabelaResultado tbody');
    const headerName = document.getElementById('headerName'); // Cabeçalho dinâmico
    const quadrasInput = document.getElementById('quadras');
    const quadrasInfoSpan = document.getElementById('quadrasInfo');
    const btnSortear = document.getElementById('btnSortear');
    const btnReiniciar = document.getElementById('btnReiniciar');
    const gameCreationMessageDiv = document.getElementById('gameCreationMessage');
    const championMessageDiv = document.getElementById('championMessage');

    // Estado global da aplicação
    let generatedGames = [];
    let currentMode = 'individual-sem-pote'; // Modo de jogo inicial
    let fixedDuosMap = {}; // Armazenará as duplas fixas para o torneio

    // Constantes para chaves do localStorage
    const LOCAL_STORAGE_KEY_GAMES = 'super8_generatedGames';
    const LOCAL_STORAGE_KEY_CONFIG = 'super8_config';
    const LOCAL_STORAGE_KEY_MODE_LOCKED = 'super8_modeLocked';
    const LOCAL_STORAGE_KEY_FIXED_DUOS = 'super8_fixedDuos'; // Nova chave para duplas fixas

    // Event listener para mudança de modo de jogo
    radiosModo.forEach(radio => radio.addEventListener('change', () => {
        currentMode = radio.value;
        if (currentMode.includes('com-pote')) {
            campoComPote.style.display = 'block';
            campoSemPote.style.display = 'none';
        } else {
            campoComPote.style.display = 'none';
            campoSemPote.style.display = 'block';
        }
        // Limpa opções de pote e informações de jogador ao mudar o modo
        poteOptionsDiv.style.display = 'none';
        playerActionInfoDiv.style.display = 'none';
        // Não reseta o localStorage aqui, apenas ao clicar em "Reiniciar"
        updateQuadrasInputLimits(); // Atualiza limites de quadras ao mudar o modo/jogadores
    }));

    // Event listener para input de jogadores/potes para atualizar limites de quadra
    jogadoresTextArea.addEventListener('input', updateQuadrasInputLimits);
    pote1TextArea.addEventListener('input', updateQuadrasInputLimits);
    pote2TextArea.addEventListener('input', updateQuadrasInputLimits);

    /**
     * Exibe uma mensagem na página em um div específico.
     * @param {string} elementId - O ID do elemento div onde a mensagem será exibida.
     * @param {string} message - A mensagem a ser exibida.
     * @param {boolean} show - True para mostrar, false para esconder.
     * @param {boolean} isError - True se for uma mensagem de erro (para estilização).
     */
    function displayMessage(elementId, message, show, isError = false) {
        const element = document.getElementById(elementId);
        if (element) {
            element.textContent = message;
            element.style.display = show ? 'block' : 'none';
            if (isError) {
                element.classList.add('error');
            } else {
                element.classList.remove('error');
            }
        }
    }

    /**
     * Salva o estado atual do jogo no localStorage.
     */
    function saveGameState() {
        const config = {
            mode: currentMode,
            jogadores: jogadoresTextArea.value,
            pote1: pote1TextArea.value,
            pote2: pote2TextArea.value,
            quadras: quadrasInput.value
        };
        localStorage.setItem(LOCAL_STORAGE_KEY_GAMES, JSON.stringify(generatedGames));
        localStorage.setItem(LOCAL_STORAGE_KEY_CONFIG, JSON.stringify(config));
        localStorage.setItem(LOCAL_STORAGE_KEY_FIXED_DUOS, JSON.stringify(fixedDuosMap));

        if (generatedGames.length > 0) {
            localStorage.setItem(LOCAL_STORAGE_KEY_MODE_LOCKED, 'true');
        } else {
            localStorage.removeItem(LOCAL_STORAGE_KEY_MODE_LOCKED);
        }
    }

    /**
     * Carrega o estado do jogo do localStorage.
     */
    function loadGameState() {
        const savedGames = localStorage.getItem(LOCAL_STORAGE_KEY_GAMES);
        const savedConfig = localStorage.getItem(LOCAL_STORAGE_KEY_CONFIG);
        const modeLocked = localStorage.getItem(LOCAL_STORAGE_KEY_MODE_LOCKED) === 'true';
        const savedFixedDuos = localStorage.getItem(LOCAL_STORAGE_KEY_FIXED_DUOS);

        if (savedGames) {
            generatedGames = JSON.parse(savedGames);
            displayGames(generatedGames);
            setConfigurationFieldsDisabled(true); // Desabilita campos se jogos já foram gerados
            // Trava os radios de modo se os jogos já foram sorteados
            radiosModo.forEach(radio => radio.disabled = modeLocked);
            // Ativa a aba "Jogos" se houver jogos salvos
            tabButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector('button[data-tab="jogos"]').classList.add('active');
            sections.forEach(sec => {
                if (sec.id === 'jogos') sec.classList.add('active');
                else sec.classList.remove('active');
            });
        }

        if (savedConfig) {
            const config = JSON.parse(savedConfig);
            currentMode = config.mode;
            jogadoresTextArea.value = config.jogadores;
            pote1TextArea.value = config.pote1;
            pote2TextArea.value = config.pote2;
            quadrasInput.value = config.quadras;

            // Define o radio button do modo de jogo
            document.querySelector(`input[name="modo"][value="${currentMode}"]`).checked = true;

            // Mostra/esconde campos de pote
            if (currentMode.includes('com-pote')) {
                campoComPote.style.display = 'block';
                campoSemPote.style.display = 'none';
            } else {
                campoComPote.style.display = 'none';
                campoSemPote.style.display = 'block';
            }
        }

        if (savedFixedDuos) {
            fixedDuosMap = JSON.parse(savedFixedDuos);
        }

        updateQuadrasInputLimits(); // Garante que os limites do input de quadras estejam corretos após o carregamento
        updateClassification(false); // Atualiza a classificação ao carregar, mas sem mostrar o pop-up de campeão
    }

    /**
     * Desabilita ou habilita os campos de configuração.
     * @param {boolean} disabled - True para desabilitar, false para habilitar.
     */
    function setConfigurationFieldsDisabled(disabled) {
        jogadoresTextArea.disabled = disabled;
        pote1TextArea.disabled = disabled;
        pote2TextArea.disabled = disabled;
        quadrasInput.disabled = disabled;
        btnSortear.disabled = disabled;
        document.getElementById('btnExcludePlayer').disabled = disabled;
        document.getElementById('btnMovePlayer').disabled = disabled; // Também desabilita o botão de mover
        // NÂO desabilita radios de modo aqui, eles são controlados por LOCAL_STORAGE_KEY_MODE_LOCKED
    }

    /**
     * Limpa o localStorage e reseta o estado da aplicação.
     * @param {boolean} confirmReset - Se true, pede confirmação ao usuário.
     */
    function resetApplicationState(confirmReset = false) {
        if (confirmReset && !confirm('Tem certeza que deseja reiniciar e apagar todas as informações?')) {
            return;
        }

        localStorage.removeItem(LOCAL_STORAGE_KEY_GAMES);
        localStorage.removeItem(LOCAL_STORAGE_KEY_CONFIG);
        localStorage.removeItem(LOCAL_STORAGE_KEY_MODE_LOCKED);
        localStorage.removeItem(LOCAL_STORAGE_KEY_FIXED_DUOS); // Limpa duplas fixas

        generatedGames = [];
        fixedDuosMap = {}; // Reseta o mapa de duplas fixas
        tabelaJogosBody.innerHTML = '';
        tabelaResultadoBody.innerHTML = '';
        jogadoresTextArea.value = '';
        pote1TextArea.value = '';
        pote2TextArea.value = '';
        quadrasInput.value = '1'; // Reseta para o valor padrão
        currentMode = 'individual-sem-pote';
        document.querySelector(`input[name="modo"][value="individual-sem-pote"]`).checked = true;
        campoComPote.style.display = 'none';
        campoSemPote.style.display = 'block';
        poteOptionsDiv.style.display = 'none';
        playerActionInfoDiv.style.display = 'none';

        setConfigurationFieldsDisabled(false); // Habilita campos
        radiosModo.forEach(radio => radio.disabled = false); // Habilita radios

        displayMessage('gameCreationMessage', '', false); // Esconde mensagens
        displayMessage('championMessage', '', false); // Esconde mensagens

        updateQuadrasInputLimits(); // Atualiza os limites de quadra
        updateClassification(false); // Limpa a tabela de classificação
    }


    /**
     * Atualiza os limites mínimo e máximo do input de quadras e a mensagem informativa.
     */
    function updateQuadrasInputLimits() {
        let players = [];
        if (currentMode.includes('sem-pote')) {
            players = jogadoresTextArea.value.split('\n').map(p => p.trim()).filter(p => p !== '');
        } else {
            const pote1Players = pote1TextArea.value.split('\n').map(p => p.trim()).filter(p => p !== '');
            const pote2Players = pote2TextArea.value.split('\n').map(p => p.trim()).filter(p => p !== '');
            players = [...pote1Players, ...pote2Players];
        }

        const numPlayers = players.length;
        const numGamesPerRound = Math.floor(numPlayers / 4); // Cada jogo tem 4 jogadores (2 duplas)
        const minQuadras = 1; // Mínimo de 1 quadra
        const maxQuadras = numGamesPerRound > 0 ? numGamesPerRound : 1; // Se não houver jogadores suficientes para um jogo, 1 quadra é o máximo

        quadrasInput.min = minQuadras;
        quadrasInput.max = maxQuadras;

        if (parseInt(quadrasInput.value) > maxQuadras) {
            quadrasInput.value = maxQuadras;
        }
        if (parseInt(quadrasInput.value) < minQuadras) {
            quadrasInput.value = minQuadras;
        }

        if (numPlayers < 4) {
            quadrasInfoSpan.textContent = `São necessários pelo menos 4 jogadores para gerar jogos. (Jogadores atuais: ${numPlayers})`;
            btnSortear.disabled = true; // Desabilita o botão se não houver jogadores suficientes
        } else {
            quadrasInfoSpan.textContent = `Número máximo de jogos simultâneos por rodada: ${maxQuadras}`;
            btnSortear.disabled = false; // Habilita se houver jogadores suficientes
        }
    }


    /**
     * Gera jogos para o modo "Individual sem pote".
     * @param {Array<string>} players - Lista de jogadores.
     * @param {number} numQuadras - Número de quadras disponíveis.
     * @returns {Array<Object>} Lista de objetos de jogos.
     */
    function generateGamesIndividualNoPot(players, numQuadras) {
        let games = [];
        let roundCounter = 1;
        let availablePlayers = [...players]; // Copia para embaralhar e manipular

        // Embaralha os jogadores
        for (let i = availablePlayers.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availablePlayers[i], availablePlayers[j]] = [availablePlayers[j], availablePlayers[i]];
        }

        // Gera jogos até que não seja possível formar mais 4 jogadores
        while (availablePlayers.length >= 4) {
            let playersInThisRound = [...availablePlayers];
            let currentRoundGames = [];
            let quadraCounter = 1;

            while (playersInThisRound.length >= 4 && quadraCounter <= numQuadras) {
                // Seleciona 4 jogadores aleatoriamente
                let selectedForGame = [];
                for (let i = 0; i < 4; i++) {
                    const randomIndex = Math.floor(Math.random() * playersInThisRound.length);
                    selectedForGame.push(playersInThisRound[randomIndex]);
                    playersInThisRound.splice(randomIndex, 1); // Remove o jogador selecionado
                }

                // Forma as duplas aleatoriamente dentro dos 4 selecionados
                selectedForGame = shuffleArray(selectedForGame); // Embaralha para formar duplas A e B
                const duplaA = [selectedForGame[0], selectedForGame[1]].sort();
                const duplaB = [selectedForGame[2], selectedForGame[3]].sort();

                currentRoundGames.push({
                    round: roundCounter,
                    court: quadraCounter,
                    duplaA: duplaA,
                    duplaB: duplaB,
                    players: [...duplaA, ...duplaB], // Todos os jogadores no jogo
                    gamesDuplaA: 0, // Inicializa com 0
                    gamesDuplaB: 0  // Inicializa com 0
                });
                quadraCounter++;
            }
            games = games.concat(currentRoundGames);
            // Remove os jogadores que participaram desta rodada da lista geral de disponíveis
            // Isso garante que cada jogador jogue o máximo de vezes possível em diferentes combinações
            availablePlayers = availablePlayers.filter(p => !currentRoundGames.some(game => game.players.includes(p)));
            roundCounter++;
        }

        return games;
    }


    /**
     * Gera jogos para o modo "Individual com pote".
     * @param {Array<string>} pote1 - Jogadores do pote 1.
     * @param {Array<string>} pote2 - Jogadores do pote 2.
     * @param {number} numQuadras - Número de quadras disponíveis.
     * @returns {Array<Object>} Lista de objetos de jogos.
     */
    function generateGamesIndividualWithPot(pote1, pote2, numQuadras) {
        let games = [];
        let roundCounter = 1;

        if (pote1.length !== pote2.length) {
            displayMessage('gameCreationMessage', 'Os potes têm números de jogadores diferentes. Por favor, ajuste.', true, true);
            // Força a exibição do popup de opções
            poteOptionsDiv.style.display = 'block';
            const diff = Math.abs(pote1.length - pote2.length);
            const largerPote = pote1.length > pote2.length ? 'Pote 1' : 'Pote 2';
            playerActionInfoDiv.textContent = `A diferença é de ${diff} jogador(es). O ${largerPote} tem mais jogadores.`;
            playerActionInfoDiv.style.display = 'block';
            return []; // Retorna array vazio para não gerar jogos
        }

        let availablePote1 = shuffleArray([...pote1]);
        let availablePote2 = shuffleArray([...pote2]);

        while (availablePote1.length >= 2 && availablePote2.length >= 2) {
            let currentRoundGames = [];
            let quadraCounter = 1;

            while (availablePote1.length >= 2 && availablePote2.length >= 2 && quadraCounter <= numQuadras) {
                const selectedP1 = availablePote1.splice(0, 2); // 2 do pote 1
                const selectedP2 = availablePote2.splice(0, 2); // 2 do pote 2

                // Uma dupla com 2 P1 e outra com 2 P2 OU duplas mistas
                // Vamos fazer duplas mistas para mais variedade: 1 P1 + 1 P2
                const dupla1 = [selectedP1[0], selectedP2[0]].sort();
                const dupla2 = [selectedP1[1], selectedP2[1]].sort();

                currentRoundGames.push({
                    round: roundCounter,
                    court: quadraCounter,
                    duplaA: dupla1,
                    duplaB: dupla2,
                    players: [...dupla1, ...dupla2],
                    gamesDuplaA: 0,
                    gamesDuplaB: 0
                });
                quadraCounter++;
            }
            games = games.concat(currentRoundGames);
            roundCounter++;

            // Se os potes ficaram vazios, recarrega para a próxima rodada
            if (availablePote1.length < 2 || availablePote2.length < 2) {
                availablePote1 = shuffleArray([...pote1]);
                availablePote2 = shuffleArray([...pote2]);
            }
        }
        return games;
    }

    /**
     * Gera jogos para o modo "Dupla Fixa sem pote".
     * @param {Array<string>} players - Lista de jogadores.
     * @param {number} numQuadras - Número de quadras disponíveis.
     * @returns {Array<Object>} Lista de objetos de jogos.
     */
    function generateGamesDuplaFixaNoPot(players, numQuadras) {
        let games = [];
        fixedDuosMap = {}; // Reinicia o mapa de duplas fixas

        if (players.length % 2 !== 0) {
            displayMessage('gameCreationMessage', 'Para dupla fixa, o número de jogadores deve ser par. Por favor, ajuste.', true, true);
            return [];
        }

        // Forma duplas aleatoriamente
        let shuffledPlayers = shuffleArray([...players]);
        let duplas = [];
        for (let i = 0; i < shuffledPlayers.length; i += 2) {
            const dupla = [shuffledPlayers[i], shuffledPlayers[i + 1]].sort().join(' & ');
            duplas.push(dupla);
            fixedDuosMap[dupla] = [shuffledPlayers[i], shuffledPlayers[i + 1]]; // Salva a composição da dupla
        }

        // Agora, gerar jogos entre as duplas
        let roundCounter = 1;
        let availableDuplas = [...duplas];

        while (availableDuplas.length >= 4) { // Pelo menos 4 duplas para 2 jogos (A vs B)
            let duplasInThisRound = [...availableDuplas];
            let currentRoundGames = [];
            let quadraCounter = 1;

            while (duplasInThisRound.length >= 4 && quadraCounter <= numQuadras) {
                let selectedForGame = []; // 4 duplas
                for (let i = 0; i < 4; i++) {
                    const randomIndex = Math.floor(Math.random() * duplasInThisRound.length);
                    selectedForGame.push(duplasInThisRound[randomIndex]);
                    duplasInThisRound.splice(randomIndex, 1);
                }

                // Forma os confrontos de duplas
                selectedForGame = shuffleArray(selectedForGame);
                const duplaA = selectedForGame[0];
                const duplaB = selectedForGame[1];
                const duplaC = selectedForGame[2]; // Duplas restantes para próximo confronto se houver
                const duplaD = selectedForGame[3];

                currentRoundGames.push({
                    round: roundCounter,
                    court: quadraCounter,
                    duplaA: duplaA,
                    duplaB: duplaB,
                    players: [...fixedDuosMap[duplaA], ...fixedDuosMap[duplaB]], // Os 4 jogadores reais
                    gamesDuplaA: 0,
                    gamesDuplaB: 0
                });
                quadraCounter++;
            }
            games = games.concat(currentRoundGames);
            // Remove as duplas que jogaram nesta rodada da lista geral de disponíveis
            availableDuplas = availableDuplas.filter(d => !currentRoundGames.some(game => game.duplaA === d || game.duplaB === d));

            // Se todas as duplas disponíveis jogaram nesta rodada, reinicia o pool de duplas para a próxima rodada
            if (availableDuplas.length < 4) {
                availableDuplas = shuffleArray([...duplas]); // Recarrega todas as duplas
            }
            roundCounter++;
        }
        return games;
    }

    /**
     * Gera jogos para o modo "Dupla Fixa com pote".
     * @param {Array<string>} pote1 - Jogadores do pote 1.
     * @param {Array<string>} pote2 - Jogadores do pote 2.
     * @param {number} numQuadras - Número de quadras disponíveis.
     * @returns {Array<Object>} Lista de objetos de jogos.
     */
    function generateGamesDuplaFixaWithPot(pote1, pote2, numQuadras) {
        let games = [];
        fixedDuosMap = {}; // Reinicia o mapa de duplas fixas

        if (pote1.length !== pote2.length || pote1.length % 2 !== 0) {
            displayMessage('gameCreationMessage', 'Para dupla fixa com pote, os potes devem ter o mesmo número de jogadores, e o número de jogadores em cada pote deve ser par. Por favor, ajuste.', true, true);
            return [];
        }

        // Forma duplas fixas com 1 P1 e 1 P2
        let shuffledP1 = shuffleArray([...pote1]);
        let shuffledP2 = shuffleArray([...pote2]);
        let duplas = [];
        for (let i = 0; i < shuffledP1.length; i++) {
            const dupla = [shuffledP1[i], shuffledP2[i]].sort().join(' & ');
            duplas.push(dupla);
            fixedDuosMap[dupla] = [shuffledP1[i], shuffledP2[i]];
        }

        // Agora, gerar jogos entre as duplas formadas
        let roundCounter = 1;
        let availableDuplas = [...duplas];

        while (availableDuplas.length >= 2) { // Mínimo de 2 duplas para um jogo (A vs B)
            let duplasInThisRound = [...availableDuplas];
            let currentRoundGames = [];
            let quadraCounter = 1;

            while (duplasInThisRound.length >= 2 && quadraCounter <= numQuadras) {
                let selectedForGame = []; // 2 duplas
                if (duplasInThisRound.length >= 2) {
                    const randomIndex1 = Math.floor(Math.random() * duplasInThisRound.length);
                    selectedForGame.push(duplasInThisRound[randomIndex1]);
                    duplasInThisRound.splice(randomIndex1, 1);

                    const randomIndex2 = Math.floor(Math.random() * duplasInThisRound.length);
                    selectedForGame.push(duplasInThisRound[randomIndex2]);
                    duplasInThisRound.splice(randomIndex2, 1);
                } else {
                    break; // Não há duplas suficientes para formar um jogo
                }

                const duplaA = selectedForGame[0];
                const duplaB = selectedForGame[1];

                currentRoundGames.push({
                    round: roundCounter,
                    court: quadraCounter,
                    duplaA: duplaA,
                    duplaB: duplaB,
                    players: [...fixedDuosMap[duplaA], ...fixedDuosMap[duplaB]],
                    gamesDuplaA: 0,
                    gamesDuplaB: 0
                });
                quadraCounter++;
            }
            games = games.concat(currentRoundGames);
            availableDuplas = availableDuplas.filter(d => !currentRoundGames.some(game => game.duplaA === d || game.duplaB === d));

            if (availableDuplas.length < 2) {
                availableDuplas = shuffleArray([...duplas]); // Recarrega todas as duplas
            }
            roundCounter++;
        }
        return games;
    }


    /**
     * Função auxiliar para embaralhar um array (Fisher-Yates).
     * @param {Array} array - O array a ser embaralhado.
     * @returns {Array} O array embaralhado.
     */
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    /**
     * Exibe os jogos na tabela.
     * @param {Array<Object>} games - Lista de objetos de jogos.
     */
    function displayGames(games) {
        tabelaJogosBody.innerHTML = ''; // Limpa a tabela existente
        games.forEach((game, index) => {
            const row = tabelaJogosBody.insertRow();
            row.dataset.gameIndex = index; // Armazena o índice do jogo na linha

            const cellRound = row.insertCell();
            cellRound.classList.add('col-rodada');
            cellRound.textContent = game.round;

            const cellCourt = row.insertCell();
            cellCourt.classList.add('col-quadra');
            cellCourt.textContent = game.court;

            const cellDuplaA = row.insertCell();
            cellDuplaA.textContent = Array.isArray(game.duplaA) ? game.duplaA.join(' & ') : game.duplaA;

            const cellResult = row.insertCell();
            cellResult.classList.add('center');
            const inputA = document.createElement('input');
            inputA.type = 'number';
            inputA.min = '0';
            inputA.value = game.gamesDuplaA;
            inputA.classList.add('result-input');
            inputA.addEventListener('change', (e) => updateResult(index, 'A', e.target.value));

            const separator = document.createTextNode(' x ');

            const inputB = document.createElement('input');
            inputB.type = 'number';
            inputB.min = '0';
            inputB.value = game.gamesDuplaB;
            inputB.classList.add('result-input');
            inputB.addEventListener('change', (e) => updateResult(index, 'B', e.target.value));

            cellResult.appendChild(inputA);
            cellResult.appendChild(separator);
            cellResult.appendChild(inputB);

            const cellDuplaB = row.insertCell();
            cellDuplaB.textContent = Array.isArray(game.duplaB) ? game.duplaB.join(' & ') : game.duplaB;
        });
    }

    /**
     * Atualiza o resultado de um jogo e salva no localStorage.
     * @param {number} gameIndex - Índice do jogo no array `generatedGames`.
     * @param {string} team - 'A' ou 'B' para indicar qual time teve o resultado atualizado.
     * @param {string} value - O novo valor do resultado (string do input).
     */
    function updateResult(gameIndex, team, value) {
        const parsedValue = parseInt(value);
        if (isNaN(parsedValue) || parsedValue < 0) {
            // Reverter para o valor anterior ou 0 se a entrada for inválida
            if (team === 'A') {
                document.querySelector(`tr[data-game-index="${gameIndex}"] input:first-of-type`).value = generatedGames[gameIndex].gamesDuplaA;
            } else {
                document.querySelector(`tr[data-game-index="${gameIndex}"] input:last-of-type`).value = generatedGames[gameIndex].gamesDuplaB;
            }
            displayMessage('gameCreationMessage', 'Por favor, insira apenas números positivos nos resultados.', true, true);
            return;
        }

        if (team === 'A') {
            generatedGames[gameIndex].gamesDuplaA = parsedValue;
        } else {
            generatedGames[gameIndex].gamesDuplaB = parsedValue;
        }
        saveGameState();
        updateClassification(false); // Atualiza a classificação, mas não mostra o pop-up de campeão
    }


    /**
     * Atualiza a classificação dos jogadores ou duplas.
     * @param {boolean} showChampionPopup - Se true, mostra a mensagem do campeão após a atualização.
     */
    function updateClassification(showChampionPopup) {
        let playerStats = {};
        let allPlayers = []; // Lista de todos os jogadores (ou duplas, se for modo dupla fixa)

        if (currentMode.includes('sem-pote')) {
            allPlayers = jogadoresTextArea.value.split('\n').map(p => p.trim()).filter(p => p !== '');
            headerName.textContent = 'Jogador';
        } else if (currentMode.includes('com-pote')) {
            const pote1Players = pote1TextArea.value.split('\n').map(p => p.trim()).filter(p => p !== '');
            const pote2Players = pote2TextArea.value.split('\n').map(p => p.trim()).filter(p => p !== '');
            allPlayers = [...pote1Players, ...pote2Players];
            headerName.textContent = 'Jogador';
        } else if (currentMode.includes('dupla-fixa')) {
            // Para duplas fixas, as "entidades" na classificação são as duplas (nomes concatenados)
            allPlayers = Object.keys(fixedDuosMap);
            headerName.textContent = 'Dupla';
        }

        // Inicializa as estatísticas para todos os jogadores/duplas
        for (const player of allPlayers) {
            playerStats[player] = { vitorias: 0, derrotas: 0, saldoGames: 0, gamesGanhos: 0, gamesPerdidos: 0, jogosDisputados: 0 };
        }

        let allGamesHaveScores = true; // Flag para verificar se todos os jogos têm placares válidos

        generatedGames.forEach(game => {
            // Verifica se o jogo tem placares válidos (soma > 0)
            const scoreA = Number(game.gamesDuplaA);
            const scoreB = Number(game.gamesDuplaB);

            if (isNaN(scoreA) || isNaN(scoreB) || (scoreA + scoreB) === 0) {
                allGamesHaveScores = false; // Há pelo menos um jogo sem placar válido
                return; // Não contabiliza estatísticas para jogos não finalizados/sem placar
            }

            const currentDuplaA = Array.isArray(game.duplaA) ? game.duplaA.join(' & ') : game.duplaA;
            const currentDuplaB = Array.isArray(game.duplaB) ? game.duplaB.join(' & ') : game.duplaB;

            // Garante que as duplas ou jogadores existam em playerStats
            if (!(currentDuplaA in playerStats)) {
                playerStats[currentDuplaA] = { vitorias: 0, derrotas: 0, saldoGames: 0, gamesGanhos: 0, gamesPerdidos: 0, jogosDisputados: 0 };
            }
            if (!(currentDuplaB in playerStats)) {
                playerStats[currentDuplaB] = { vitorias: 0, derrotas: 0, saldoGames: 0, gamesGanhos: 0, gamesPerdidos: 0, jogosDisputados: 0 };
            }

            // Atualiza estatísticas de games
            playerStats[currentDuplaA].gamesGanhos += scoreA;
            playerStats[currentDuplaA].gamesPerdidos += scoreB;
            playerStats[currentDuplaA].saldoGames += (scoreA - scoreB);

            playerStats[currentDuplaB].gamesGanhos += scoreB;
            playerStats[currentDuplaB].gamesPerdidos += scoreA;
            playerStats[currentDuplaB].saldoGames += (scoreB - scoreA);

            // Atualiza vitórias/derrotas e jogos disputados
            if (scoreA > scoreB) {
                playerStats[currentDuplaA].vitorias++;
                playerStats[currentDuplaB].derrotas++;
            } else if (scoreB > scoreA) {
                playerStats[currentDuplaB].vitorias++;
                playerStats[currentDuplaA].derrotas++;
            }
            // Empate não contabiliza vitória/derrota (não deveria acontecer em Beach Tennis normal)
            
            playerStats[currentDuplaA].jogosDisputados++;
            playerStats[currentDuplaB].jogosDisputados++;
        });

        // Converte o objeto de estatísticas em um array para ordenação
        let sortedStats = Object.keys(playerStats).map(name => ({ name, ...playerStats[name] }));

        // Remove jogadores "Livre" da classificação, eles não competem
        sortedStats = sortedStats.filter(stats => stats.name.toLowerCase() !== 'livre');

        // Ordena pela maior número de vitórias, depois maior saldo de games
        sortedStats.sort((a, b) => {
            if (a.vitorias !== b.vitorias) {
                return b.vitorias - a.vitorias; // Mais vitórias primeiro
            }
            if (a.saldoGames !== b.saldoGames) {
                return b.saldoGames - a.saldoGames; // Maior saldo de games primeiro
            }
            // Critério de desempate por confronto direto (se aplicável e implementado)
            // Esta parte é mais complexa e exigiria rastrear cada confronto
            return 0; // Se tudo igual, a ordem original se mantém
        });

        // Limpa e preenche a tabela de resultados
        tabelaResultadoBody.innerHTML = '';
        sortedStats.forEach((stats, index) => {
            const row = tabelaResultadoBody.insertRow();
            const positionCell = row.insertCell();
            positionCell.textContent = index + 1; // Posição

            const nameCell = row.insertCell();
            nameCell.textContent = stats.name; // Nome do jogador/dupla

            row.insertCell().textContent = stats.vitorias;
            row.insertCell().textContent = stats.derrotas;
            row.insertCell().textContent = stats.saldoGames;
            row.insertCell().textContent = stats.gamesGanhos;
            row.insertCell().textContent = stats.gamesPerdidos;
        });

        // Lógica para exibir o campeão
        if (showChampionPopup) {
            if (allGamesHaveScores) {
                if (sortedStats.length > 0) {
                    const champion = sortedStats[0];
                    let championName = champion.name;

                    // Verifica se há empate na primeira posição
                    let tiedChampions = sortedStats.filter(s =>
                        s.vitorias === champion.vitorias &&
                        s.saldoGames === champion.saldoGames
                    );

                    if (tiedChampions.length > 1) {
                        const tiedNames = tiedChampions.map(c => c.name).join(', ');
                        displayMessage('championMessage', `Houve um empate na primeira posição entre: ${tiedNames}. Consulte os critérios de desempate abaixo.`, true);
                    } else {
                        displayMessage('championMessage', `Parabéns, ${championName}! Você é o campeão!`, true);
                    }
                } else {
                    displayMessage('championMessage', 'Não há jogadores/duplas para determinar o campeão.', true, true);
                }
            } else {
                displayMessage('championMessage', 'O campeão será exibido quando todos os jogos tiverem um placar registrado (soma dos games acima de 0).', true, true);
            }
        }
    }


    // --- Gerenciamento de Sorteio ---
    document.getElementById('btnSortear').addEventListener('click', handleSortGames);
    document.getElementById('btnReiniciar').addEventListener('click', () => resetApplicationState(true));

    function handleSortGames() {
        displayMessage('gameCreationMessage', '', false); // Esconde mensagens anteriores
        displayMessage('championMessage', '', false); // Esconde mensagens anteriores

        let playersOrPot1 = [];
        let pote2Players = [];
        const numQuadras = parseInt(quadrasInput.value);

        if (currentMode.includes('sem-pote')) {
            playersOrPot1 = jogadoresTextArea.value.split('\n').map(p => p.trim()).filter(p => p !== '');
            if (playersOrPot1.length < 4) {
                displayMessage('gameCreationMessage', 'É necessário um mínimo de 4 jogadores para gerar jogos.', true, true);
                return;
            }
        } else { // Modos com pote
            playersOrPot1 = pote1TextArea.value.split('\n').map(p => p.trim()).filter(p => p !== '');
            pote2Players = pote2TextArea.value.split('\n').map(p => p.trim()).filter(p => p !== '');

            if (playersOrPot1.length === 0 || pote2Players.length === 0) {
                displayMessage('gameCreationMessage', 'Ambos os potes devem conter jogadores.', true, true);
                return;
            }
            if (playersOrPot1.length !== pote2Players.length) {
                 // Esta validação agora é feita dentro da função de geração de jogos
                generatedGames = []; // Garante que nenhum jogo seja gerado se os potes forem diferentes
                return; // Retorna para que a mensagem da função de geração seja exibida
            }
        }

        if (currentMode === 'individual-sem-pote') {
            generatedGames = generateGamesIndividualNoPot(playersOrPot1, numQuadras);
        } else if (currentMode === 'individual-com-pote') {
            generatedGames = generateGamesIndividualWithPot(playersOrPot1, pote2Players, numQuadras);
        } else if (currentMode === 'dupla-fixa-sem-pote') {
            generatedGames = generateGamesDuplaFixaNoPot(playersOrPot1, numQuadras);
        } else if (currentMode === 'dupla-fixa-com-pote') {
            generatedGames = generateGamesDuplaFixaWithPot(playersOrPot1, pote2Players, numQuadras);
        }

        if (generatedGames.length === 0) {
            displayMessage('gameCreationMessage', 'Não foi possível gerar jogos com as configurações atuais. Verifique o número de jogadores/duplas e o modo de jogo.', true, true);
            return;
        }

        displayGames(generatedGames);
        updateClassification(false); // Não mostra pop-up de campeão no sorteio inicial
        saveGameState();
        setConfigurationFieldsDisabled(true);
        radiosModo.forEach(radio => radio.disabled = true);

        // Mudar para a aba "Jogos" após o sorteio
        tabButtons.forEach(btn => btn.classList.remove('active'));
        document.querySelector('button[data-tab="jogos"]').classList.add('active');
        sections.forEach(sec => {
            if (sec.id === 'jogos') sec.classList.add('active');
            else sec.classList.remove('active');
        });

        // Exibir mensagem de sucesso após o sorteio e mudança de aba
        displayMessage('gameCreationMessage', 'Os jogos foram criados com sucesso!', true);
    }


    // --- Lógica para Potes Diferentes (excluir/mover jogador) ---
    document.getElementById('btnExcludePlayer').addEventListener('click', () => {
        let pote1Players = pote1TextArea.value.split('\n').map(p => p.trim()).filter(p => p !== '');
        let pote2Players = pote2TextArea.value.split('\n').map(p => p.trim()).filter(p => p !== '');

        if (pote1Players.length === pote2Players.length) {
            displayMessage('gameCreationMessage', 'Os potes já têm o mesmo número de jogadores.', true, true);
            return;
        }

        let largerPote = [];
        let largerPoteName = '';
        if (pote1Players.length > pote2Players.length) {
            largerPote = pote1Players;
            largerPoteName = 'Pote 1';
        } else {
            largerPote = pote2Players;
            largerPoteName = 'Pote 2';
        }

        // Exibe um alerta e remove o último jogador do pote maior
        const playerToRemove = largerPote[largerPote.length - 1];
        if (confirm(`Remover "${playerToRemove}" do ${largerPoteName}?`)) {
            largerPote.pop();
            if (largerPoteName === 'Pote 1') {
                pote1TextArea.value = largerPote.join('\n');
            } else {
                pote2TextArea.value = largerPote.join('\n');
            }
            displayMessage('gameCreationMessage', `"${playerToRemove}" foi removido do ${largerPoteName}.`, true);
            poteOptionsDiv.style.display = 'none'; // Esconde opções após a ação
            playerActionInfoDiv.style.display = 'none';
            updateQuadrasInputLimits();
        }
    });


    // Carrega o estado do jogo ao carregar a página
    window.addEventListener('load', loadGameState);
</script>
</body>
</html>
