<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Super 8 - Beach Tennis</title>
<style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      margin: 0; padding: 0; background: #f0f2f5; color: #333;
      display: flex !important;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      background: #2980b9; color: white; padding: 1rem; text-align: center;
      font-weight: 700; font-size: 1.4rem;
    }
    main {
      max-width: 900px;
      width: 100%;
      margin: 1rem auto;
      background: white; border-radius: 8px; box-shadow: 0 0 10px rgb(0 0 0 / 0.1);
      padding: 1rem 2rem 2rem 2rem;
      box-sizing: border-box; /* Garante que padding não adicione largura */
    }
    nav {
      display: flex; border-bottom: 2px solid #2980b9; margin-bottom: 1rem;
      flex-wrap: wrap; /* Permite que os botões quebrem a linha */
      justify-content: center; /* Centraliza botões em telas menores */
    }
    nav button {
      flex: 1; background: transparent; border: none; padding: 1rem; font-size: 1rem; cursor: pointer; font-weight: 600; color: #2980b9;
      border-bottom: 3px solid transparent; transition: 0.3s ease;
      min-width: 120px; /* Garante um tamanho mínimo para os botões */
    }
    nav button.active {
      border-bottom-color: #2980b9; color: #145a86;
    }
    section {
      display: none;
    }
    section.active {
      display: block;
    }
    label {
      display: block; margin-top: 0.8rem; font-weight: 600;
    }
    textarea, input[type=text], input[type=number] { /* Adicionado input[type=number] */
      width: 100%; padding: 8px; margin-top: 0.3rem; border-radius: 4px; border: 1px solid #ccc; font-size: 1rem;
      box-sizing: border-box;
    }
    textarea {
      resize: vertical;
    }
    fieldset {
      border: 1px solid #ccc; border-radius: 5px; padding: 10px 15px 15px 15px; margin-top: 1rem;
    }
    legend {
      font-weight: 700; color: #2980b9; padding: 0 6px;
    }
    button.action-btn {
      background: #2980b9; color: white; border: none; padding: 10px 20px; margin-top: 15px; border-radius: 5px; cursor: pointer;
      font-weight: 700; margin-right: 10px;
      white-space: nowrap; /* Evita que o texto do botão quebre */
    }
    button.action-btn:hover {
      background: #1c5d86;
    }
    button.action-btn:disabled {
        background: #cccccc;
        cursor: not-allowed;
    }
    table {
      width: 100%; border-collapse: collapse; margin-top: 1rem;
      display: block; /* Permite scroll horizontal em tabelas grandes */
      overflow-x: auto; /* Adiciona scroll horizontal */
      white-space: nowrap; /* Impede que o conteúdo da célula quebre */
    }
    th, td {
      border: 1px solid #ddd; padding: 8px; text-align: center;
    }
    th {
      background: #2980b9; color: white;
    }
    .col-rodada {
        width: 10%;
        min-width: 60px;
    }
    .col-quadra {
        width: 10%;
        min-width: 60px;
    }

    input.result-input {
      width: 50px; text-align: center; font-weight: 600; font-size: 1rem; border: 1px solid #2980b9; border-radius: 4px;
    }
    .center {
      text-align: center;
    }
    .player-highlight {
        font-weight: bold;
        color: red;
        font-size: 1.1rem;
    }
    .option-buttons {
        margin-top: 15px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap; /* Permite que os botões quebrem a linha */
    }
    #quadrasInputContainer {
        margin-top: 15px;
        display: flex; /* Permite alinhar label e input na mesma linha */
        align-items: center; /* Alinha verticalmente */
        gap: 10px; /* Espaçamento entre os itens */
        flex-wrap: wrap; /* Permite quebrar a linha em telas pequenas */
    }
    #quadrasInputContainer label {
        margin-top: 0; /* Remove margin-top extra, já que está em flexbox */
        margin-bottom: 0;
    }
    #quadras {
        width: auto;
        padding: 5px;
        text-align: center;
        flex-grow: 0; /* Impede que o input de quadras cresça desnecessariamente */
        min-width: 50px; /* Garante que seja visível */
    }

    .popup {
        display: none;
        position: fixed;
        z-index: 1;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgb(0,0,0);
        background-color: rgba(0,0,0,0.4);
        padding-top: 60px;
    }
    .popup-content {
        background-color: #fefefe;
        margin: 15% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
        max-width: 400px;
        border-radius: 8px;
        box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
        animation-name: animatetop;
        animation-duration: 0.4s
    }
    @keyframes animatetop {
        from {top: -300px; opacity: 0}
        to {top: 0; opacity: 1}
    }
    .popup-close {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
    }
    .popup-close:hover,
    .popup-close:focus {
        color: black;
        text-decoration: none;
        cursor: pointer;
    }

    footer {
        text-align: center;
        padding: 1rem;
        background: #2980b9;
        color: white;
        margin-top: auto;
        font-size: 0.9rem; /* Ajuste para fonte menor no footer */
    }

    .criteria-text {
        margin-top: 1rem;
        font-size: 0.9em;
        color: #555;
    }
    .criteria-list {
        margin-left: 1.5rem;
        padding-left: 0;
    }

    /* Media Queries para dispositivos móveis */
    @media (max-width: 768px) {
        main {
            margin: 0.5rem auto;
            padding: 1rem; /* Reduz o padding em telas menores */
        }
        nav button {
            font-size: 0.9rem;
            padding: 0.8rem;
            flex-basis: 48%; /* Duas colunas para botões de navegação */
            margin-bottom: 0.5rem; /* Espaçamento entre as linhas de botões */
        }
        .option-buttons button.action-btn {
            flex-basis: 100%; /* Botões de opção em coluna única */
            margin-right: 0;
            margin-bottom: 10px;
        }
        #quadrasInputContainer {
            flex-direction: column; /* Empilha label e input */
            align-items: flex-start; /* Alinha à esquerda */
        }
        #quadras {
            width: 100px; /* Largura fixa para o input de quadras em mobile */
        }
    }

    @media (max-width: 600px) {
      nav button {
        font-size: 0.85rem; /* Fonte ainda menor */
        padding: 0.7rem;
      }
      table, th, td {
        font-size: 0.8rem;
        padding: 6px; /* Reduz o padding da tabela */
      }
      th, td {
        white-space: normal; /* Permite que o texto da célula quebre para melhor visualização */
      }
      .col-rodada, .col-quadra {
        min-width: auto; /* Remove min-width para essas colunas */
      }
      .popup-content {
        margin: 10% auto; /* Ajusta a margem superior do popup */
        width: 90%; /* Aumenta a largura do popup */
        padding: 15px; /* Reduz o padding do popup */
      }
    }

    @media (max-width: 400px) {
        nav button {
            font-size: 0.8rem;
            padding: 0.6rem;
            flex-basis: 100%; /* Botões de navegação em coluna única */
        }
        button.action-btn {
            font-size: 0.9rem;
            padding: 8px 15px;
        }
    }
</style>
</head>
<body>

<header>Super 8 - Beach Tennis</header>

<main>
    <nav>
        <button class="tab-button active" data-tab="config">Configuração</button>
        <button class="tab-button" data-tab="jogos">Jogos</button>
        <button class="tab-button" data-tab="resultado">Resultado</button>
    </nav>

    <section id="config" class="active">
        <fieldset>
            <legend>Modo de Jogo</legend>
            <label><input type="radio" name="modo" value="individual-sem-pote" checked> Individual sem pote</label>
            <label><input type="radio" name="modo" value="individual-com-pote"> Individual com pote</label>
            <label><input type="radio" name="modo" value="dupla-fixa-sem-pote"> Dupla fixa sem pote</label>
            <label><input type="radio" name="modo" value="dupla-fixa-com-pote"> Dupla fixa com pote</label>
        </fieldset>

        <div id="campoSemPote">
            <label for="jogadores">Jogadores (um por linha):</label>
            <textarea id="jogadores" rows="8" placeholder="Exemplo: Lucas&#10;Maria&#10;Pedro&#10;Ana">Lucas
Maria
Pedro
Ana
João
Carla
Paulo
Marina</textarea>
        </div>

        <div id="campoComPote" style="display:none;">
            <label for="pote1">Pote 1 (um por linha):</label>
            <textarea id="pote1" rows="6" placeholder="Exemplo: Lucas&#10;Pedro&#10;João&#10;Paulo">A
B
C
D</textarea>

            <label for="pote2">Pote 2 (um por linha):</label>
            <textarea id="pote2" rows="6" placeholder="Exemplo: Maria&#10;Ana&#10;Carla&#10;Marina">1
2
3
4</textarea>
            <div id="poteOptions" style="display:none;">
                <p>Os potes têm números de jogadores diferentes. Escolha uma opção:</p>
                <div class="option-buttons">
                    <button class="action-btn" id="btnExcludePlayer">Excluir um jogador do pote maior</button>
                    <button class="action-btn" id="btnMovePlayer" style="display:none;">Mover um jogador para o outro pote</button>
                </div>
                <div id="playerActionInfo" class="player-highlight" style="display:none;"></div>
            </div>
        </div>
        
        <div id="quadrasInputContainer">
            <label for="quadras">Quantidade de Quadras:</label>
            <input type="number" id="quadras" value="1" min="1">
            <span id="quadrasInfo" style="font-size: 0.9em; color: #555;"></span>
        </div>
        
        <div id="sortResultInfo" style="margin-top: 1rem; font-weight: bold; color: green;"></div>

        <button class="action-btn" id="btnSortear">Sortear Jogos</button>
        <button class="action-btn" id="btnReiniciar">Reiniciar</button>
    </section>

    <section id="jogos">
        <table id="tabelaJogos">
            <thead>
                <tr>
                    <th class="col-rodada">Rodada</th>
                    <th class="col-quadra">Quadra</th>
                    <th>Dupla A</th>
                    <th>Resultado (Games)</th> 
                    <th>Dupla B</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
    </section>

    <section id="resultado">
        <table id="tabelaResultado">
            <thead>
                <tr>
                    <th>Posição</th>
                    <th id="headerName">Jogador</th> 
                    <th>Vitórias</th>
                    <th>Derrotas</th>
                    <th>Saldo de Games</th> 
                    <th>Games Ganhados</th>
                    <th>Games Perdidos</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
        <p class="criteria-text">
            **Critérios de Desempate:**
            <ol class="criteria-list">
                <li>Maior número de **Vitórias**</li>
                <li>Maior **Saldo de Games** (Games Ganhados - Games Perdidos)</li>
                <li>Em caso de novo empate, o critério é o **Confronto Direto** (quem ganhou o jogo entre os empatados)</li>
            </ol>
        </p>
        <div id="championInfoDiv" style="margin-top: 1.5rem; font-size: 1.1em; text-align: center; font-weight: bold; color: #2980b9;"></div>
    </section>
</main>

<footer>
    © 2025 Todos os direitos reservados. Proibida a cópia ou reprodução.<br>
    Desenvolvido por Lauro Licce.
</footer>

<div id="infoPopup" class="popup">
    <div class="popup-content">
        <span class="popup-close">&times;</span>
        <h3 id="popupTitle"></h3>
        <p id="popupMessage"></p>
    </div>
</div>

<script>
    // Gerenciamento de abas
    const tabButtons = document.querySelectorAll('.tab-button');
    const sections = document.querySelectorAll('main section');

    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            const targetTab = button.dataset.tab;
            sections.forEach(section => {
                if (section.id === targetTab) section.classList.add('active');
                else section.classList.remove('active');
            });
            // Quando muda para a aba de resultado, atualiza a classificação (sem mostrar pop-up de campeão)
            if (targetTab === 'resultado') {
                updateClassification(); // showChampionPopup is now handled internally without a parameter
            }
        });
    });

    // Referências a elementos DOM
    const radiosModo = document.querySelectorAll('input[name="modo"]');
    const campoSemPote = document.getElementById('campoSemPote');
    const campoComPote = document.getElementById('campoComPote');
    const poteOptionsDiv = document.getElementById('poteOptions');
    const playerActionInfoDiv = document.getElementById('playerActionInfo');
    const btnMovePlayer = document.getElementById('btnMovePlayer');
    const jogadoresTextArea = document.getElementById('jogadores');
    const pote1TextArea = document.getElementById('pote1');
    const pote2TextArea = document.getElementById('pote2');
    const tabelaJogosBody = document.querySelector('#tabelaJogos tbody');
    const tabelaResultadoBody = document.querySelector('#tabelaResultado tbody');
    const headerName = document.getElementById('headerName');
    const quadrasInput = document.getElementById('quadras');
    const quadrasInfoSpan = document.getElementById('quadrasInfo');
    const infoPopup = document.getElementById('infoPopup');
    const popupTitle = document.getElementById('popupTitle');
    const popupMessage = document.getElementById('popupMessage');
    const popupClose = document.querySelector('.popup-close');
    const btnSortear = document.getElementById('btnSortear');
    const btnReiniciar = document.getElementById('btnReiniciar');
    const championInfoDiv = document.getElementById('championInfoDiv'); // Novo div para info do campeão
    const sortResultInfo = document.getElementById('sortResultInfo'); // Novo div para info do sorteio

    // Estado global da aplicação
    let generatedGames = [];
    let currentMode = 'individual-sem-pote';
    let fixedDuosMap = {};

    // Constantes para chaves do localStorage
    const LOCAL_STORAGE_KEY_GAMES = 'super8_generatedGames';
    const LOCAL_STORAGE_KEY_CONFIG = 'super8_config';
    const LOCAL_STORAGE_KEY_MODE_LOCKED = 'super8_modeLocked';
    const LOCAL_STORAGE_KEY_FIXED_DUOS = 'super8_fixedDuos';

    // Event listener para mudança de modo de jogo
    radiosModo.forEach(radio => radio.addEventListener('change', () => {
        currentMode = radio.value;
        if (currentMode.includes('com-pote')) {
            campoComPote.style.display = 'block';
            campoSemPote.style.display = 'none';
        } else {
            campoComPote.style.display = 'none';
            campoSemPote.style.display = 'block';
        }
        poteOptionsDiv.style.display = 'none';
        playerActionInfoDiv.style.display = 'none';
        updateQuadrasInputLimits();
    }));

    // Event listener para input de jogadores/potes para atualizar limites de quadra
    jogadoresTextArea.addEventListener('input', updateQuadrasInputLimits);
    pote1TextArea.addEventListener('input', updateQuadrasInputLimits);
    pote2TextArea.addEventListener('input', updateQuadrasInputLimits);

    // Event listener para fechar o pop-up
    popupClose.addEventListener('click', () => {
        infoPopup.style.display = 'none';
    });
    window.addEventListener('click', (event) => {
        if (event.target == infoPopup) {
            infoPopup.style.display = 'none';
        }
    });

    /**
     * Exibe o pop-up com um título e mensagem.
     * @param {string} title - O título do pop-up.
     * @param {string} message - A mensagem a ser exibida no pop-up.
     */
    function showPopup(title, message) {
        popupTitle.textContent = title;
        popupMessage.innerHTML = message;
        infoPopup.style.display = 'block';
    }

    /**
     * Salva o estado atual do jogo no localStorage.
     */
    function saveGameState() {
        const config = {
            mode: currentMode,
            jogadores: jogadoresTextArea.value,
            pote1: pote1TextArea.value,
            pote2: pote2TextArea.value,
            quadras: quadrasInput.value
        };
        localStorage.setItem(LOCAL_STORAGE_KEY_GAMES, JSON.stringify(generatedGames));
        localStorage.setItem(LOCAL_STORAGE_KEY_CONFIG, JSON.stringify(config));
        localStorage.setItem(LOCAL_STORAGE_KEY_FIXED_DUOS, JSON.stringify(fixedDuosMap));

        if (generatedGames.length > 0) {
            localStorage.setItem(LOCAL_STORAGE_KEY_MODE_LOCKED, 'true');
        } else {
            localStorage.removeItem(LOCAL_STORAGE_KEY_MODE_LOCKED);
        }
    }

    /**
     * Carrega o estado do jogo do localStorage.
     */
    function loadGameState() {
        const savedGames = localStorage.getItem(LOCAL_STORAGE_KEY_GAMES);
        const savedConfig = localStorage.getItem(LOCAL_STORAGE_KEY_CONFIG);
        const modeLocked = localStorage.getItem(LOCAL_STORAGE_KEY_MODE_LOCKED) === 'true';
        const savedFixedDuos = localStorage.getItem(LOCAL_STORAGE_KEY_FIXED_DUOS);

        if (savedConfig) {
            const config = JSON.parse(savedConfig);
            currentMode = config.mode;
            
            document.querySelector(`input[name="modo"][value="${currentMode}"]`).checked = true;

            if (currentMode.includes('com-pote')) {
                campoComPote.style.display = 'block';
                campoSemPote.style.display = 'none';
            } else {
                campoComPote.style.display = 'none';
                campoSemPote.style.display = 'block';
            }

            jogadoresTextArea.value = config.jogadores || 'Lucas\nMaria\nPedro\nAna\nJoão\nCarla\nPaulo\nMarina';
            pote1TextArea.value = config.pote1 || 'A\nB\nC\nD';
            pote2TextArea.value = config.pote2 || '1\n2\n3\n4';
            quadrasInput.value = config.quadras || 1;
        } else {
            resetApplicationState(false); 
        }

        if (savedFixedDuos) {
            fixedDuosMap = JSON.parse(savedFixedDuos);
        }

        if (savedGames) {
            generatedGames = JSON.parse(savedGames);
            displayGames(generatedGames);
            updateClassification();
            tabButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector('button[data-tab="jogos"]').classList.add('active');
            sections.forEach(sec => {
                if (sec.id === 'jogos') sec.classList.add('active');
                else sec.classList.remove('active');
            });
            setConfigurationFieldsDisabled(true); 
            radiosModo.forEach(radio => radio.disabled = modeLocked);
            sortResultInfo.textContent = 'Os jogos foram criados com sucesso!'; // Restore success message

        } else {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector('button[data-tab="config"]').classList.add('active');
            sections.forEach(sec => {
                if (sec.id === 'config') sec.classList.add('active');
                else sec.classList.remove('active');
            });
            setConfigurationFieldsDisabled(false);
            radiosModo.forEach(radio => radio.disabled = false);
            sortResultInfo.textContent = ''; // Clear message if no games are loaded
        }
        updateQuadrasInputLimits(); 
    }

    /**
     * Embaralha um array (Fisher-Yates shuffle).
     * @param {Array} array - O array a ser embaralhado.
     */
    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    /**
     * Normaliza a entrada de texto de jogadores/potes para um array limpo de strings.
     * Remove espaços em branco extras e linhas vazias.
     * @param {string} text - O texto de entrada do textarea.
     * @returns {Array<string>} Um array de nomes de jogadores.
     */
    function parsePlayerInput(text) {
        return text.split('\n')
                   .map(player => player.trim())
                   .filter(player => player !== '');
    }

    /**
     * Calcula o número máximo de quadras com base no número de jogadores.
     * 1 quadra para cada 4 jogadores (ou 2 duplas), arredondado para baixo.
     * @param {number} numPlayers - O número total de jogadores.
     * @param {string} mode - O modo de jogo ('individual' ou 'dupla').
     * @returns {number} O número máximo de quadras.
     */
    function calculateMaxQuadras(numPlayers, mode) {
        if (mode === 'dupla') {
            return Math.floor(numPlayers / 2);
        } else {
            return Math.floor(numPlayers / 4);
        }
    }

    /**
     * Atualiza os limites (min/max) do input de quadras e exibe uma mensagem.
     */
    function updateQuadrasInputLimits() {
        let playersCount = 0;
        let modeForCalculation = 'individual'; 

        if (currentMode.includes('com-pote')) {
            const pote1 = parsePlayerInput(pote1TextArea.value);
            const pote2 = parsePlayerInput(pote2TextArea.value);
            
            if (currentMode.startsWith('dupla-fixa')) {
                modeForCalculation = 'dupla';
                // Para duplas fixas com pote, o número de "duplas" é o tamanho do menor pote.
                // Cada dupla ocupa 2 "slots" em uma partida de 4 pessoas.
                // Então, o número de "players" para cálculo do maxQuadras é o dobro do número de duplas.
                playersCount = Math.min(pote1.length, pote2.length) * 2; 
            } else {
                playersCount = pote1.length + pote2.length;
            }
        } else {
            const players = parsePlayerInput(jogadoresTextArea.value);
            playersCount = players.length;
            if (currentMode.startsWith('dupla-fixa')) {
                modeForCalculation = 'dupla';
                playersCount = Math.ceil(players.length / 2) * 2; // Representa o número de "jogadores" se fossem duplas fixas
            }
        }
        
        const maxQuadras = calculateMaxQuadras(playersCount, modeForCalculation);
        
        quadrasInput.min = 1;
        quadrasInput.max = Math.max(1, maxQuadras); 

        quadrasInfoSpan.textContent = `(Máximo ${quadrasInput.max} quadra${quadrasInput.max > 1 ? 's' : ''})`;

        if (parseInt(quadrasInput.value) > quadrasInput.max) {
            quadrasInput.value = quadrasInput.max;
        }
    }

    /**
     * Habilita ou desabilita os campos de configuração.
     * @param {boolean} disabled - True para desabilitar, False para habilitar.
     */
    function setConfigurationFieldsDisabled(disabled) {
        jogadoresTextArea.disabled = disabled;
        pote1TextArea.disabled = disabled;
        pote2TextArea.disabled = disabled;
        quadrasInput.disabled = disabled;
        btnSortear.disabled = disabled;
        
        if (disabled) {
            poteOptionsDiv.style.display = 'none';
        }
    }

    // --- Funções de Geração de Jogos ---

    /**
     * Gera todos os jogos possíveis para o modo "Individual sem Pote" usando Round-Robin
     * e os distribui sequencialmente pelas quadras disponíveis.
     * Garante que todos os jogos sejam gerados, independentemente do número de quadras,
     * e os atribui a rodadas e quadras de forma sequential.
     * @param {Array<string>} players - Lista de nomes dos jogadores.
     * @returns {Array<Object>} Lista de jogos gerados com rodada e quadra atribuídas.
     */
    function generateGamesIndividualNoPot(players) {
        let allPlayers = [...players];
        const n = allPlayers.length;

        if (n < 4) {
            alert("Para o modo 'Individual sem pote', você precisa de pelo menos 4 jogadores para formar duplas.");
            return [];
        }

        let tempPlayers = [...allPlayers];
        let effectiveN = n;
        
        if (effectiveN % 2 !== 0) {
            tempPlayers.push('Livre');
            effectiveN++;
        }

        const numRoundsTheoretical = effectiveN - 1;
        let allPotentialGames = [];

        for (let r = 0; r < numRoundsTheoretical; r++) {
            let roundDuos = [];
            const fixedPlayer = tempPlayers[0];
            const rotatingPlayers = tempPlayers.slice(1);

            for (let i = 0; i < effectiveN / 2; i++) {
                let p1, p2;
                if (i === 0) {
                    p1 = fixedPlayer;
                    p2 = rotatingPlayers[rotatingPlayers.length - 1 - i];
                } else {
                    p1 = rotatingPlayers[i - 1];
                    p2 = rotatingPlayers[rotatingPlayers.length - 1 - i];
                }
                roundDuos.push([p1, p2]);
            }
            
            shuffle(roundDuos);

            const playableDuos = roundDuos.filter(duo => !duo.includes('Livre'));
            for (let i = 0; i < playableDuos.length; i += 2) {
                if (i + 1 < playableDuos.length) {
                    allPotentialGames.push({
                        duplaA: playableDuos[i],
                        duplaB: playableDuos[i + 1],
                        gamesDuplaA: 0, // Inicializa com 0
                        gamesDuplaB: 0  // Inicializa com 0
                    });
                }
            }

            const lastPlayer = rotatingPlayers.pop();
            rotatingPlayers.unshift(lastPlayer);
            tempPlayers = [fixedPlayer, ...rotatingPlayers];
        }

        let finalGames = [];
        const numQuadras = parseInt(quadrasInput.value);
        let currentRound = 1;
        let currentQuadra = 1;

        allPotentialGames.forEach(game => {
            finalGames.push({
                ...game,
                rodada: currentRound,
                quadra: currentQuadra
            });

            currentQuadra++;
            if (currentQuadra > numQuadras) {
                currentQuadra = 1;
                currentRound++;
            }
        });
        
        return finalGames;
    }

    /**
     * Gera jogos para o modo "Individual com Pote", garantindo que cada dupla PoteA-PoteB
     * seja única ao longo de todo o torneio, e que cada jogo tenha 4 jogadores únicos.
     * Tenta encontrar uma solução que balanceie os jogos entre os jogadores, priorizando quem jogou menos recentemente.
     * Prioriza a variação nas duplas adversárias.
     * @param {Array<string>} pote1 - Jogadores do Pote 1.
     * @param {Array<string>} pote2 - Jogadores do Pote 2.
     * @returns {Array<Object>} Lista de jogos gerados.
     */
    function generateGamesIndividualWithPot(pote1, pote2) {
        const numPote1 = pote1.length;
        const numPote2 = pote2.length;
        const numQuadras = parseInt(quadrasInput.value);

        if (numPote1 < 2 || numPote2 < 2) {
            alert("Para o modo 'Individual com pote', você precisa de pelo menos 2 jogadores em cada pote para formar jogos válidos (dupla contra dupla).");
            return [];
        }

        let allPlayers = [...pote1, ...pote2];
        let lastPlayedRound = {};
        allPlayers.forEach(p => (lastPlayedRound[p] = -1));
        
        let allPossibleP1P2Duos = [];
        pote1.forEach(pA => {
            pote2.forEach(pB => {
                allPossibleP1P2Duos.push([pA, pB]);
            });
        });
        
        let finalGames = [];
        let usedP1P2DuosInTournament = new Set();
        let usedPlayerPairsAsOpponents = new Set();

        const arePlayersUnique = (pA1, pB1, pA2, pB2) => {
            return new Set([pA1, pB1, pA2, pB2]).size === 4;
        };

        const haveDuosPlayedBefore = (duo1, duo2) => {
            const players = [...duo1, ...duo2].sort();
            return usedPlayerPairsAsOpponents.has(players.join('|'));
        };

        const markDuosAsOpponents = (duo1, duo2) => {
            const players = [...duo1, ...duo2].sort();
            usedPlayerPairsAsOpponents.add(players.join('|'));
        };

        let rodadaCounter = 1;
        
        let allGeneratedGames = [];

        let safetyBreak = 0;
        const MAX_ITERATIONS = 500;

        while (safetyBreak < MAX_ITERATIONS) {
            let gamesThisRoundAttempt = [];
            let playersUsedInCurrentAttempt = new Set(); 
            let availableP1P2Duos = allPossibleP1P2Duos.filter(duo => !usedP1P2DuosInTournament.has(duo.join('|')));
            
            shuffle(availableP1P2Duos);

            availableP1P2Duos.sort((duo1, duo2) => {
                const lp1_1 = lastPlayedRound[duo1[0]];
                const lp1_2 = lastPlayedRound[duo1[1]];
                const lp2_1 = lastPlayedRound[duo2[0]];
                const lp2_2 = lastPlayedRound[duo2[1]];

                const inactivitySum1 = (rodadaCounter - lp1_1) + (rodadaCounter - lp1_2);
                const inactivitySum2 = (rodadaCounter - lp2_1) + (rodadaCounter - lp2_2);

                return inactivitySum2 - inactivitySum1;
            });


            for (let i = 0; i < availableP1P2Duos.length; i++) {
                const teamA = availableP1P2Duos[i];
                if (playersUsedInCurrentAttempt.has(teamA[0]) || playersUsedInCurrentAttempt.has(teamA[1])) {
                    continue;
                }

                for (let j = i + 1; j < availableP1P2Duos.length; j++) {
                    const teamB = availableP1P2Duos[j];
                    if (playersUsedInCurrentAttempt.has(teamB[0]) || playersUsedInCurrentAttempt.has(teamB[1])) {
                        continue;
                    }

                    if (!arePlayersUnique(teamA[0], teamA[1], teamB[0], teamB[1])) {
                        continue;
                    }
                    
                    if (haveDuosPlayedBefore(teamA, teamB)) {
                        continue;
                    }

                    gamesThisRoundAttempt.push({ 
                        duplaA: teamA, 
                        duplaB: teamB,
                        gamesDuplaA: 0, // Inicializa com 0
                        gamesDuplaB: 0  // Inicializa com 0
                    });
                    
                    playersUsedInCurrentAttempt.add(teamA[0]);
                    playersUsedInCurrentAttempt.add(teamA[1]);
                    playersUsedInCurrentAttempt.add(teamB[0]);
                    playersUsedInCurrentAttempt.add(teamB[1]);

                    usedP1P2DuosInTournament.add(teamA.join('|'));
                    usedP1P2DuosInTournament.add(teamB.join('|'));
                    markDuosAsOpponents(teamA, teamB); 
                    
                    if (gamesThisRoundAttempt.length >= numQuadras) {
                        break; 
                    }
                }
                if (gamesThisRoundAttempt.length >= numQuadras) {
                    break;
                }
            }
            
            if (gamesThisRoundAttempt.length === 0) {
                break; 
            }

            allGeneratedGames.push(...gamesThisRoundAttempt);

            playersUsedInCurrentAttempt.forEach(player => {
                lastPlayedRound[player] = rodadaCounter;
            });

            rodadaCounter++;
            safetyBreak++;
        }
        
        let currentAssignedRound = 1;
        let currentAssignedQuadra = 1;
        allGeneratedGames.forEach(game => {
            finalGames.push({
                ...game,
                rodada: currentAssignedRound,
                quadra: currentAssignedQuadra
            });
            currentAssignedQuadra++;
            if (currentAssignedQuadra > numQuadras) {
                currentAssignedQuadra = 1;
                currentAssignedRound++;
            }
        });

        return finalGames;
    }


    /**
     * Gera duplas fixas a partir de uma lista de jogadores.
     * Se houver um número ímpar de jogadores, o último jogador é pareado com 'Livre'.
     * Armazena as duplas geradas em fixedDuosMap para uso na classificação.
     * @param {Array<string>} players - Lista de nomes dos jogadores.
     * @returns {Array<Array<string>>} Lista de duplas fixas.
     */
    function generateFixedDuos(players) {
        const shuffledPlayers = [...players];
        shuffle(shuffledPlayers);
        let duos = [];
        fixedDuosMap = {}; // Resetar fixedDuosMap a cada geração para evitar lixo de estado anterior
        for (let i = 0; i < shuffledPlayers.length; i += 2) {
            let duo;
            if (i + 1 < shuffledPlayers.length) {
                duo = [shuffledPlayers[i], shuffledPlayers[i + 1]].sort();
            } else {
                duo = [shuffledPlayers[i], 'Livre'].sort();
            }
            duos.push(duo);
            fixedDuosMap[duo.join(' & ')] = duo.join(' & '); // Armazena a dupla normalizada como chave e valor
        }
        return duos;
    }

    /**
     * Gera jogos para o modo "Dupla Fixa sem Pote" usando Round-Robin
     * e os distribui sequencialmente pelas quadras disponíveis.
     * @param {Array<string>} players - Lista de nomes dos jogadores para formar duplas.
     * @returns {Array<Object>} Lista de jogos gerados com rodada e quadra atribuída.
     */
    function generateGamesFixedDuoNoPot(players) {
        const fixedDuos = generateFixedDuos(players);
        let allPotentialGames = [];
        const numQuadras = parseInt(quadrasInput.value);

        let tempDuos = [...fixedDuos];
        if (tempDuos.length % 2 !== 0) {
            tempDuos.push(['Livre', 'Livre']);
        }
        
        const numDuplas = tempDuos.length;
        const numRoundsTheoretical = numDuplas - 1;

        for (let r = 0; r < numRoundsTheoretical; r++) {
            let gamesInRoundTheoretical = [];
            for (let i = 0; i < numDuplas / 2; i++) {
                const duplaA = tempDuos[i];
                const duplaB = tempDuos[numDuplas - 1 - i];

                if (!duplaA.includes('Livre') && !duplaB.includes('Livre')) {
                    gamesInRoundTheoretical.push({
                        duplaA: duplaA,
                        duplaB: duplaB,
                        gamesDuplaA: 0,
                        gamesDuplaB: 0
                    });
                }
            }
            shuffle(gamesInRoundTheoretical); // Embaralha os jogos dentro da rodada

            allPotentialGames.push(...gamesInRoundTheoretical);

            const lastDuo = tempDuos.pop();
            tempDuos.splice(1, 0, lastDuo);
        }

        let finalGames = [];
        let currentRound = 1;
        let currentQuadra = 1;

        allPotentialGames.forEach(game => {
            finalGames.push({
                ...game,
                rodada: currentRound,
                quadra: currentQuadra
            });

            currentQuadra++;
            if (currentQuadra > numQuadras) {
                currentQuadra = 1;
                currentRound++;
            }
        });

        return finalGames;
    }

    /**
     * Gera jogos para o modo "Dupla Fixa com Pote".
     * Pareia duplas de Pote 1 com duplas de Pote 2.
     * @param {Array<string>} pote1 - Jogadores do Pote 1.
     * @param {Array<string>} pote2 - Jogadores do Pote 2.
     * @returns {Array<Object>} Lista de jogos gerados.
     */
    function generateGamesFixedDuoWithPot(pote1, pote2) {
        if (pote1.length % 2 !== 0 || pote2.length % 2 !== 0) {
            showPopup("Erro", "Para o modo 'Dupla fixa com pote', o número de jogadores em cada pote deve ser par.");
            return [];
        }

        const duplasPote1 = [];
        for (let i = 0; i < pote1.length; i += 2) {
            duplasPote1.push([pote1[i], pote1[i + 1]].sort());
        }

        const duplasPote2 = [];
        for (let i = 0; i < pote2.length; i += 2) {
            duplasPote2.push([pote2[i], pote2[i + 1]].sort());
        }

        if (duplasPote1.length < 2 || duplasPote2.length < 2) {
            alert("Para o modo 'Dupla fixa com pote', você precisa de pelo menos 2 duplas em cada pote para formar jogos válidos.");
            return [];
        }

        let allPossibleMatches = [];
        duplasPote1.forEach(dA => {
            duplasPote2.forEach(dB => {
                allPossibleMatches.push({
                    duplaA: dA,
                    duplaB: dB,
                    gamesDuplaA: 0,
                    gamesDuplaB: 0
                });
            });
        });
        
        shuffle(allPossibleMatches); // Embaralha as possíveis partidas

        let finalGames = [];
        const numQuadras = parseInt(quadrasInput.value);
        let currentRound = 1;
        let currentQuadra = 1;

        // Distribui as partidas pelas quadras e rodadas
        allPossibleMatches.forEach(game => {
            finalGames.push({
                ...game,
                rodada: currentRound,
                quadra: currentQuadra
            });

            currentQuadra++;
            if (currentQuadra > numQuadras) {
                currentQuadra = 1;
                currentRound++;
            }
        });

        // Atualiza fixedDuosMap para as duplas fixas
        duplasPote1.forEach(duo => fixedDuosMap[duo.join(' & ')] = duo.join(' & '));
        duplasPote2.forEach(duo => fixedDuosMap[duo.join(' & ')] = duo.join(' & '));

        return finalGames;
    }


    // --- Lógica do Sorteio e Exibição ---

    /**
     * Manipula o clique do botão Sortear Jogos.
     */
    btnSortear.addEventListener('click', () => {
        if (localStorage.getItem(LOCAL_STORAGE_KEY_MODE_LOCKED)) {
            showPopup("Aviso", "O sorteio já foi realizado e os resultados foram salvos. Para um novo sorteio, por favor, clique em **Reiniciar**.");
            return;
        }

        let players;
        let pote1, pote2;
        let games = [];

        if (currentMode.includes('com-pote')) {
            pote1 = parsePlayerInput(pote1TextArea.value);
            pote2 = parsePlayerInput(pote2TextArea.value);

            if (pote1.length === 0 || pote2.length === 0) {
                showPopup("Erro de Entrada", "Os potes não podem estar vazios no modo 'com pote'. Por favor, insira os nomes dos jogadores.");
                return;
            }

            if (pote1.length !== pote2.length) {
                playerActionInfoDiv.innerHTML = `O Pote 1 tem ${pote1.length} jogador(es) e o Pote 2 tem ${pote2.length} jogador(es).`;
                poteOptionsDiv.style.display = 'block';
                btnMovePlayer.style.display = 'none'; // Desativa mover jogador inicialmente
                if (Math.abs(pote1.length - pote2.length) === 1) {
                    btnMovePlayer.style.display = 'inline-block';
                }
                showPopup("Ajuste Necessário", "O número de jogadores nos potes é diferente. Por favor, ajuste antes de sortear.");
                return;
            } else {
                poteOptionsDiv.style.display = 'none';
                playerActionInfoDiv.style.display = 'none';
            }

            if (currentMode === 'individual-com-pote') {
                games = generateGamesIndividualWithPot(pote1, pote2);
            } else if (currentMode === 'dupla-fixa-com-pote') {
                games = generateGamesFixedDuoWithPot(pote1, pote2);
            }
        } else { // Modos sem pote
            players = parsePlayerInput(jogadoresTextArea.value);
            if (players.length === 0) {
                showPopup("Erro de Entrada", "A lista de jogadores não pode estar vazia. Por favor, insira os nomes dos jogadores.");
                return;
            }
            if (currentMode === 'individual-sem-pote') {
                games = generateGamesIndividualNoPot(players);
            } else if (currentMode === 'dupla-fixa-sem-pote') {
                games = generateGamesFixedDuoNoPot(players);
            }
        }

        if (games.length === 0) {
            sortResultInfo.textContent = 'Não foi possível gerar jogos com a configuração atual.';
            sortResultInfo.style.color = 'red';
            generatedGames = [];
            saveGameState();
            displayGames(generatedGames);
            return;
        }

        generatedGames = games;
        displayGames(generatedGames);
        saveGameState();
        updateClassification(); // Atualiza a classificação na aba de resultados
        
        // Transiciona para a aba de jogos
        tabButtons.forEach(btn => btn.classList.remove('active'));
        document.querySelector('button[data-tab="jogos"]').classList.add('active');
        sections.forEach(sec => {
            if (sec.id === 'jogos') sec.classList.add('active');
            else sec.classList.remove('active');
        });
        setConfigurationFieldsDisabled(true); // Desabilita campos após sorteio
        radiosModo.forEach(radio => radio.disabled = true);
        sortResultInfo.textContent = 'Os jogos foram criados com sucesso!';
        sortResultInfo.style.color = 'green';
    });


    /**
     * Exibe os jogos gerados na tabela de jogos.
     * @param {Array<Object>} games - Lista de jogos a serem exibidos.
     */
    function displayGames(games) {
        tabelaJogosBody.innerHTML = '';
        if (games.length === 0) {
            const row = tabelaJogosBody.insertRow();
            const cell = row.insertCell();
            cell.colSpan = 5;
            cell.textContent = 'Nenhum jogo gerado ainda.';
            return;
        }

        games.sort((a, b) => {
            if (a.rodada !== b.rodada) return a.rodada - b.rodada;
            return a.quadra - b.quadra;
        });

        games.forEach((game, index) => {
            const row = tabelaJogosBody.insertRow();
            row.dataset.gameIndex = index; // Para fácil referência no salvamento de resultados

            const rodadaCell = row.insertCell();
            rodadaCell.textContent = game.rodada;

            const quadraCell = row.insertCell();
            quadraCell.textContent = game.quadra;

            const duplaACell = row.insertCell();
            duplaACell.textContent = game.duplaA.join(' & ');

            const resultCell = row.insertCell();
            resultCell.className = 'center';

            const inputA = document.createElement('input');
            inputA.type = 'number';
            inputA.min = '0';
            inputA.max = '100'; // Um valor alto para games
            inputA.value = game.gamesDuplaA;
            inputA.className = 'result-input';
            inputA.dataset.team = 'A';
            inputA.addEventListener('change', handleResultChange);

            const separator = document.createTextNode(' x ');

            const inputB = document.createElement('input');
            inputB.type = 'number';
            inputB.min = '0';
            inputB.max = '100'; // Um valor alto para games
            inputB.value = game.gamesDuplaB;
            inputB.className = 'result-input';
            inputB.dataset.team = 'B';
            inputB.addEventListener('change', handleResultChange);

            resultCell.appendChild(inputA);
            resultCell.appendChild(separator);
            resultCell.appendChild(inputB);

            const duplaBCell = row.insertCell();
            duplaBCell.textContent = game.duplaB.join(' & ');
        });
    }

    /**
     * Atualiza os resultados de um jogo quando os inputs de games são alterados.
     * @param {Event} event - O evento de mudança do input.
     */
    function handleResultChange(event) {
        const input = event.target;
        const row = input.closest('tr');
        const gameIndex = parseInt(row.dataset.gameIndex);
        const team = input.dataset.team;
        let value = parseInt(input.value);

        if (isNaN(value) || value < 0) {
            value = 0;
            input.value = 0;
        }
        
        if (team === 'A') {
            generatedGames[gameIndex].gamesDuplaA = value;
        } else {
            generatedGames[gameIndex].gamesDuplaB = value;
        }
        saveGameState();
        updateClassification();
    }

    /**
     * Calcula e exibe a classificação dos jogadores/duplas.
     * Ignora o parâmetro showChampionPopup, a lógica de popup é interna agora.
     */
    function updateClassification() {
        let stats = {};

        // Inicializa estatísticas com base no modo
        if (currentMode.startsWith('dupla-fixa')) {
            // Para duplas fixas, as chaves são as duplas normalizadas
            Object.keys(fixedDuosMap).forEach(duoKey => {
                stats[duoKey] = {
                    vitorias: 0,
                    derrotas: 0,
                    gamesGanhados: 0,
                    gamesPerdidos: 0,
                    saldoGames: 0,
                    jogosJogados: 0,
                    confrontos: {} // Para confronto direto
                };
            });
            headerName.textContent = 'Dupla';
        } else {
            // Para modos individuais, as chaves são os jogadores
            let allPlayers = new Set();
            if (currentMode.includes('com-pote')) {
                parsePlayerInput(pote1TextArea.value).forEach(p => allPlayers.add(p));
                parsePlayerInput(pote2TextArea.value).forEach(p => allPlayers.add(p));
            } else {
                parsePlayerInput(jogadoresTextArea.value).forEach(p => allPlayers.add(p));
            }
            allPlayers.forEach(player => {
                stats[player] = {
                    vitorias: 0,
                    derrotas: 0,
                    gamesGanhados: 0,
                    gamesPerdidos: 0,
                    saldoGames: 0,
                    jogosJogados: 0,
                    confrontos: {}
                };
            });
            headerName.textContent = 'Jogador';
        }

        generatedGames.forEach(game => {
            const teamAKey = currentMode.startsWith('dupla-fixa') ? game.duplaA.sort().join(' & ') : '';
            const teamBKey = currentMode.startsWith('dupla-fixa') ? game.duplaB.sort().join(' & ') : '';

            const gamesA = game.gamesDuplaA;
            const gamesB = game.gamesDuplaB;

            if (currentMode.startsWith('dupla-fixa')) {
                if (stats[teamAKey]) {
                    stats[teamAKey].gamesGanhados += gamesA;
                    stats[teamAKey].gamesPerdidos += gamesB;
                    stats[teamAKey].saldoGames = stats[teamAKey].gamesGanhados - stats[teamAKey].gamesPerdidos;
                }
                if (stats[teamBKey]) {
                    stats[teamBKey].gamesGanhados += gamesB;
                    stats[teamBKey].gamesPerdidos += gamesA;
                    stats[teamBKey].saldoGames = stats[teamBKey].gamesGanhados - stats[teamBKey].gamesPerdidos;
                }

                if (gamesA > gamesB) {
                    if (stats[teamAKey]) stats[teamAKey].vitorias++;
                    if (stats[teamBKey]) stats[teamBKey].derrotas++;
                    // Confronto direto
                    if (stats[teamAKey] && stats[teamBKey]) {
                        stats[teamAKey].confrontos[teamBKey] = true; // A venceu B
                        stats[teamBKey].confrontos[teamAKey] = false; // B perdeu para A
                    }
                } else if (gamesB > gamesA) {
                    if (stats[teamBKey]) stats[teamBKey].vitorias++;
                    if (stats[teamAKey]) stats[teamAKey].derrotas++;
                    // Confronto direto
                    if (stats[teamAKey] && stats[teamBKey]) {
                        stats[teamAKey].confrontos[teamBKey] = false; // A perdeu para B
                        stats[teamBKey].confrontos[teamAKey] = true; // B venceu A
                    }
                }
            } else { // Modo Individual
                game.duplaA.forEach(player => {
                    if (stats[player]) {
                        stats[player].gamesGanhados += gamesA;
                        stats[player].gamesPerdidos += gamesB;
                        stats[player].saldoGames = stats[player].gamesGanhados - stats[player].gamesPerdidos;
                    }
                });
                game.duplaB.forEach(player => {
                    if (stats[player]) {
                        stats[player].gamesGanhados += gamesB;
                        stats[player].gamesPerdidos += gamesA;
                        stats[player].saldoGames = stats[player].gamesGanhados - stats[player].gamesPerdidos;
                    }
                });

                if (gamesA > gamesB) {
                    game.duplaA.forEach(player => { if (stats[player]) stats[player].vitorias++; });
                    game.duplaB.forEach(player => { if (stats[player]) stats[player].derrotas++; });
                } else if (gamesB > gamesA) {
                    game.duplaB.forEach(player => { if (stats[player]) stats[player].vitorias++; });
                    game.duplaA.forEach(player => { if (stats[player]) stats[player].derrotas++; });
                }
            }
        });

        // Converte o objeto de estatísticas em um array e ordena
        let classification = Object.keys(stats).map(name => ({
            name: name,
            ...stats[name]
        }));

        classification.sort((a, b) => {
            // 1. Vitórias
            if (a.vitorias !== b.vitorias) return b.vitorias - a.vitorias;
            // 2. Saldo de Games
            if (a.saldoGames !== b.saldoGames) return b.saldoGames - a.saldoGames;
            
            // 3. Confronto Direto (apenas se houver empate em vitórias e saldo e for Dupla Fixa)
            if (currentMode.startsWith('dupla-fixa')) {
                // Verificar se A ganhou de B diretamente
                if (a.confrontos[b.name] === true) return -1;
                // Verificar se B ganhou de A diretamente
                if (b.confrontos[a.name] === true) return 1;
            }
            
            // Se tudo empatar, mantém a ordem original (ou alfabética)
            return 0;
        });

        tabelaResultadoBody.innerHTML = '';
        if (classification.length === 0) {
            const row = tabelaResultadoBody.insertRow();
            const cell = row.insertCell();
            cell.colSpan = 7;
            cell.textContent = 'Nenhum resultado para exibir ainda.';
            championInfoDiv.textContent = '';
            return;
        }

        classification.forEach((entry, index) => {
            const row = tabelaResultadoBody.insertRow();
            row.insertCell().textContent = index + 1; // Posição
            row.insertCell().textContent = entry.name; // Nome do jogador/dupla
            row.insertCell().textContent = entry.vitorias;
            row.insertCell().textContent = entry.derrotas;
            row.insertCell().textContent = entry.saldoGames;
            row.insertCell().textContent = entry.gamesGanhados;
            row.insertCell().textContent = entry.gamesPerdidos;
        });

        // Lógica para determinar e exibir o campeão
        if (classification.length > 0) {
            const champion = classification[0];
            const hasTieForFirst = classification.length > 1 && 
                                   champion.vitorias === classification[1].vitorias &&
                                   champion.saldoGames === classification[1].saldoGames &&
                                   (currentMode.startsWith('individual') || // No individual, se vitórias e saldo empatam, é empate
                                    (!champion.confrontos[classification[1].name] && !classification[1].confrontos[champion.name])); // Na dupla fixa, verifica confronto direto
            
            if (!hasTieForFirst) {
                championInfoDiv.textContent = `🏆 O campeão é: ${champion.name}! 🎉`;
            } else {
                let tiedChampions = [champion.name];
                for (let i = 1; i < classification.length; i++) {
                    if (classification[i].vitorias === champion.vitorias &&
                        classification[i].saldoGames === champion.saldoGames) {
                        // Verifica o confronto direto apenas para dupla-fixa
                        if (currentMode.startsWith('individual') || 
                            (!champion.confrontos[classification[i].name] && !classification[i].confrontos[champion.name])) {
                            tiedChampions.push(classification[i].name);
                        } else {
                            break; // Se há confronto direto e um dos dois venceu, o empate foi quebrado
                        }
                    } else {
                        break;
                    }
                }
                if (tiedChampions.length > 1) {
                    championInfoDiv.textContent = `Houve um empate para o primeiro lugar entre: ${tiedChampions.join(', ')}.`;
                } else {
                     championInfoDiv.textContent = `🏆 O campeão é: ${champion.name}! 🎉`;
                }
            }
        } else {
            championInfoDiv.textContent = '';
        }
    }


    // --- Lógica para o Pote Diferente (Excluir/Mover) ---

    // Event listener para o botão de Excluir Jogador
    document.getElementById('btnExcludePlayer').addEventListener('click', () => {
        let pote1 = parsePlayerInput(pote1TextArea.value);
        let pote2 = parsePlayerInput(pote2TextArea.value);
        
        let targetPote;
        let playerToRemove;

        if (pote1.length > pote2.length) {
            targetPote = pote1;
            playerToRemove = targetPote[Math.floor(Math.random() * targetPote.length)]; // Remove aleatoriamente
            pote1TextArea.value = targetPote.filter(p => p !== playerToRemove).join('\n');
            playerActionInfoDiv.textContent = `"${playerToRemove}" foi removido do Pote 1.`;
        } else if (pote2.length > pote1.length) {
            targetPote = pote2;
            playerToRemove = targetPote[Math.floor(Math.random() * targetPote.length)]; // Remove aleatoriamente
            pote2TextArea.value = targetPote.filter(p => p !== playerToRemove).join('\n');
            playerActionInfoDiv.textContent = `"${playerToRemove}" foi removido do Pote 2.`;
        }
        playerActionInfoDiv.style.display = 'block';
        poteOptionsDiv.style.display = 'none'; // Esconde as opções após a ação
        showPopup("Ajuste Realizado", playerActionInfoDiv.textContent);
        updateQuadrasInputLimits(); // Re-avalia o número de quadras após a mudança
    });

    // Event listener para o botão de Mover Jogador
    btnMovePlayer.addEventListener('click', () => {
        let pote1 = parsePlayerInput(pote1TextArea.value);
        let pote2 = parsePlayerInput(pote2TextArea.value);

        let playerToMove;
        if (pote1.length > pote2.length) {
            playerToMove = pote1.pop(); // Remove do Pote 1
            pote2.push(playerToMove);   // Adiciona ao Pote 2
            pote1TextArea.value = pote1.join('\n');
            pote2TextArea.value = pote2.join('\n');
            playerActionInfoDiv.textContent = `"${playerToMove}" foi movido do Pote 1 para o Pote 2.`;
        } else if (pote2.length > pote1.length) {
            playerToMove = pote2.pop(); // Remove do Pote 2
            pote1.push(playerToMove);   // Adiciona ao Pote 1
            pote1TextArea.value = pote1.join('\n');
            pote2TextArea.value = pote2.join('\n');
            playerActionInfoDiv.textContent = `"${playerToMove}" foi movido do Pote 2 para o Pote 1.`;
        }
        playerActionInfoDiv.style.display = 'block';
        poteOptionsDiv.style.display = 'none'; // Esconde as opções após a ação
        showPopup("Ajuste Realizado", playerActionInfoDiv.textContent);
        updateQuadrasInputLimits(); // Re-avalia o número de quadras após a mudança
    });


    /**
     * Reinicia o estado da aplicação.
     * @param {boolean} confirmBeforeReset - Se true, pede confirmação antes de reiniciar.
     */
    btnReiniciar.addEventListener('click', () => {
        resetApplicationState(true); // Pede confirmação antes de reiniciar
    });

    function resetApplicationState(confirmBeforeReset = false) {
        const performReset = () => {
            generatedGames = [];
            fixedDuosMap = {};
            localStorage.removeItem(LOCAL_STORAGE_KEY_GAMES);
            localStorage.removeItem(LOCAL_STORAGE_KEY_CONFIG);
            localStorage.removeItem(LOCAL_STORAGE_KEY_MODE_LOCKED);
            localStorage.removeItem(LOCAL_STORAGE_KEY_FIXED_DUOS);

            // Reseta os campos para valores padrão
            jogadoresTextArea.value = 'Lucas\nMaria\nPedro\nAna\nJoão\nCarla\nPaulo\nMarina';
            pote1TextArea.value = 'A\nB\nC\nD';
            pote2TextArea.value = '1\n2\n3\n4';
            quadrasInput.value = 1;

            // Restaura o modo padrão e visibilidade dos campos
            document.querySelector('input[name="modo"][value="individual-sem-pote"]').checked = true;
            currentMode = 'individual-sem-pote';
            campoSemPote.style.display = 'block';
            campoComPote.style.display = 'none';
            poteOptionsDiv.style.display = 'none';
            playerActionInfoDiv.style.display = 'none';

            // Limpa as tabelas
            tabelaJogosBody.innerHTML = '<tr><td colspan="5">Nenhum jogo gerado ainda.</td></tr>';
            tabelaResultadoBody.innerHTML = '<tr><td colspan="7">Nenhum resultado para exibir ainda.</td></tr>';
            championInfoDiv.textContent = '';
            sortResultInfo.textContent = '';

            // Habilita os campos de configuração e os rádios de modo
            setConfigurationFieldsDisabled(false);
            radiosModo.forEach(radio => radio.disabled = false);

            // Volta para a aba de configuração
            tabButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector('button[data-tab="config"]').classList.add('active');
            sections.forEach(sec => {
                if (sec.id === 'config') sec.classList.add('active');
                else sec.classList.remove('active');
            });
            updateQuadrasInputLimits(); // Atualiza os limites da quadra
            showPopup("Reiniciado", "O estado do aplicativo foi resetado com sucesso!");
        };

        if (confirmBeforeReset) {
            if (confirm("Tem certeza que deseja reiniciar o jogo? Todos os dados serão perdidos.")) {
                performReset();
            }
        } else {
            performReset();
        }
    }


    // Inicialização ao carregar a página
    document.addEventListener('DOMContentLoaded', () => {
        loadGameState();
    });
</script>
</body>
</html>
