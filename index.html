<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Super 8 - Beach Tennis</title>
<style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      margin: 0; padding: 0; background: #f0f2f5; color: #333;
      display: flex !important;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      background: #2980b9; color: white; padding: 1rem; text-align: center;
      font-weight: 700; font-size: 1.4rem;
    }
    main {
      max-width: 900px;
      width: 100%;
      margin: 1rem auto;
      background: white; border-radius: 8px; box-shadow: 0 0 10px rgb(0 0 0 / 0.1);
      padding: 1rem 2rem 2rem 2rem;
    }
    nav {
      display: flex; border-bottom: 2px solid #2980b9; margin-bottom: 1rem;
    }
    nav button {
      flex: 1; background: transparent; border: none; padding: 1rem; font-size: 1rem; cursor: pointer; font-weight: 600; color: #2980b9;
      border-bottom: 3px solid transparent; transition: 0.3s ease;
    }
    nav button.active {
      border-bottom-color: #2980b9; color: #145a86;
    }
    section {
      display: none;
    }
    section.active {
      display: block;
    }
    label {
      display: block; margin-top: 0.8rem; font-weight: 600;
    }
    textarea, input[type=text] {
      width: 100%; padding: 8px; margin-top: 0.3rem; border-radius: 4px; border: 1px solid #ccc; font-size: 1rem;
      box-sizing: border-box;
    }
    textarea {
      resize: vertical;
    }
    fieldset {
      border: 1px solid #ccc; border-radius: 5px; padding: 10px 15px 15px 15px; margin-top: 1rem;
    }
    legend {
      font-weight: 700; color: #2980b9; padding: 0 6px;
    }
    button.action-btn {
      background: #2980b9; color: white; border: none; padding: 10px 20px; margin-top: 15px; border-radius: 5px; cursor: pointer;
      font-weight: 700; margin-right: 10px;
    }
    button.action-btn:hover {
      background: #1c5d86;
    }
    button.action-btn:disabled {
        background: #cccccc;
        cursor: not-allowed;
    }
    table {
      width: 100%; border-collapse: collapse; margin-top: 1rem;
    }
    th, td {
      border: 1px solid #ddd; padding: 8px; text-align: center;
    }
    th {
      background: #2980b9; color: white;
    }
    .col-rodada {
        width: 10%;
        min-width: 60px;
    }
    .col-quadra {
        width: 10%;
        min-width: 60px;
    }

    input.result-input {
      width: 50px; text-align: center; font-weight: 600; font-size: 1rem; border: 1px solid #2980b9; border-radius: 4px;
    }
    .center {
      text-align: center;
    }
    .player-highlight {
        font-weight: bold;
        color: red;
        font-size: 1.1rem;
    }
    .option-buttons {
        margin-top: 15px;
        display: flex;
        gap: 10px;
    }
    #quadrasInputContainer {
        margin-top: 15px;
    }
    #quadrasInputContainer label {
        display: inline-block;
        margin-right: 10px;
    }
    #quadras {
        width: auto;
        padding: 5px;
        text-align: center;
    }

    .popup {
        display: none;
        position: fixed;
        z-index: 1;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgb(0,0,0);
        background-color: rgba(0,0,0,0.4);
        padding-top: 60px;
    }
    .popup-content {
        background-color: #fefefe;
        margin: 15% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
        max-width: 400px;
        border-radius: 8px;
        box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
        animation-name: animatetop;
        animation-duration: 0.4s
    }
    @keyframes animatetop {
        from {top: -300px; opacity: 0}
        to {top: 0; opacity: 1}
    }
    .popup-close {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
    }
    .popup-close:hover,
    .popup-close:focus {
        color: black;
        text-decoration: none;
        cursor: pointer;
    }

    footer {
        text-align: center;
        padding: 1rem;
        background: #2980b9;
        color: white;
        margin-top: auto;
    }

    .criteria-text {
        margin-top: 1rem;
        font-size: 0.9em;
        color: #555;
    }
    .criteria-list {
        margin-left: 1.5rem;
        padding-left: 0;
    }

    @media (max-width: 600px) {
      main {
        padding: 1rem; /* Adjust padding for smaller screens */
      }
      nav button {
        font-size: 0.9rem;
        padding: 8px;
      }
      table, th, td {
        font-size: 0.8rem;
      }
      .col-rodada, .col-quadra {
        min-width: unset; /* Remove min-width for better responsiveness */
        width: 15%; /* Adjust width for smaller screens */
      }
    }
</style>
</head>
<body>

<header>Super 8 - Beach Tennis</header>

<main>
    <nav>
        <button class="tab-button active" data-tab="config">Configuração</button>
        <button class="tab-button" data-tab="jogos">Jogos</button>
        <button class="tab-button" data-tab="resultado">Resultado</button>
    </nav>

    <section id="config" class="active">
        <fieldset>
            <legend>Modo de Jogo</legend>
            <label><input type="radio" name="modo" value="individual-sem-pote" checked> Individual sem pote</label>
            <label><input type="radio" name="modo" value="individual-com-pote"> Individual com pote</label>
            <label><input type="radio" name="modo" value="dupla-fixa-sem-pote"> Dupla fixa sem pote</label>
            <label><input type="radio" name="modo" value="dupla-fixa-com-pote"> Dupla fixa com pote</label>
        </fieldset>

        <div id="campoSemPote">
            <label for="jogadores">Jogadores (um por linha):</label>
            <textarea id="jogadores" rows="8" placeholder="Exemplo: Lucas&#10;Maria&#10;Pedro&#10;Ana"></textarea>
        </div>

        <div id="campoComPote" style="display:none;">
            <label for="pote1">Pote 1 (um por linha):</label>
            <textarea id="pote1" rows="6" placeholder="Exemplo: Lucas&#10;Pedro&#10;João&#10;Paulo"></textarea>

            <label for="pote2">Pote 2 (um por linha):</label>
            <textarea id="pote2" rows="6" placeholder="Exemplo: Maria&#10;Ana&#10;Carla&#10;Marina"></textarea>
            <div id="poteOptions" style="display:none;">
                <p>Os potes têm números de jogadores diferentes. Escolha uma opção:</p>
                <div class="option-buttons">
                    <button class="action-btn" id="btnExcludePlayer">Excluir um jogador do pote maior</button>
                    <button class="action-btn" id="btnMovePlayer" style="display:none;">Mover um jogador para o outro pote</button>
                </div>
                <div id="playerActionInfo" class="player-highlight" style="display:none;"></div>
            </div>
        </div>
        
        <div id="quadrasInputContainer">
            <label for="quadras">Quantidade de Quadras:</label>
            <input type="number" id="quadras" value="1" min="1">
            <span id="quadrasInfo" style="font-size: 0.9em; color: #555;"></span>
        </div>
        
        <div id="sortResultInfo" style="margin-top: 1rem; font-weight: bold; color: green;"></div>

        <button class="action-btn" id="btnSortear">Sortear Jogos</button>
        <button class="action-btn" id="btnReiniciar">Reiniciar</button>
    </section>

    <section id="jogos">
        <table id="tabelaJogos">
            <thead>
                <tr>
                    <th class="col-rodada">Rodada</th>
                    <th class="col-quadra">Quadra</th>
                    <th>Dupla A</th>
                    <th>Resultado (Games)</th> 
                    <th>Dupla B</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
    </section>

    <section id="resultado">
        <table id="tabelaResultado">
            <thead>
                <tr>
                    <th>Posição</th>
                    <th id="headerName">Jogador</th> 
                    <th>Vitórias</th>
                    <th>Derrotas</th>
                    <th>Saldo de Games</th> 
                    <th>Games Ganhados</th>
                    <th>Games Perdidos</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
        <p class="criteria-text">
            **Critérios de Desempate:**
            <ol class="criteria-list">
                <li>Maior número de **Vitórias**</li>
                <li>Maior **Saldo de Games** (Games Ganhados - Games Perdidos)</li>
                <li>Em caso de novo empate, o critério é o **Confronto Direto** (quem ganhou o jogo entre os empatados)</li>
            </ol>
        </p>
        <div id="championInfoDiv" style="margin-top: 1.5rem; font-size: 1.1em; text-align: center; font-weight: bold; color: #2980b9;"></div>
    </section>
</main>

<footer>
    © 2025 Todos os direitos reservados. Proibida a cópia ou reprodução.<br>
    Desenvolvido por Lauro Licce. Modificações v1.0.0
</footer>

<div id="infoPopup" class="popup">
    <div class="popup-content">
        <span class="popup-close">&times;</span>
        <h3 id="popupTitle"></h3>
        <p id="popupMessage"></p>
    </div>
</div>

<script>
    // Gerenciamento de abas
    const tabButtons = document.querySelectorAll('.tab-button');
    const sections = document.querySelectorAll('main section');

    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            const targetTab = button.dataset.tab;
            sections.forEach(section => {
                if (section.id === targetTab) section.classList.add('active');
                else section.classList.remove('active');
            });
            // Quando muda para a aba de resultado, atualiza a classificação (sem mostrar pop-up de campeão)
            if (targetTab === 'resultado') {
                updateClassification(); // showChampionPopup is now handled internally without a parameter
            }
        });
    });

    // Referências a elementos DOM
    const radiosModo = document.querySelectorAll('input[name="modo"]');
    const campoSemPote = document.getElementById('campoSemPote');
    const campoComPote = document.getElementById('campoComPote');
    const poteOptionsDiv = document.getElementById('poteOptions');
    const playerActionInfoDiv = document.getElementById('playerActionInfo');
    const btnMovePlayer = document.getElementById('btnMovePlayer');
    const jogadoresTextArea = document.getElementById('jogadores');
    const pote1TextArea = document.getElementById('pote1');
    const pote2TextArea = document.getElementById('pote2');
    const tabelaJogosBody = document.querySelector('#tabelaJogos tbody');
    const tabelaResultadoBody = document.querySelector('#tabelaResultado tbody');
    const headerName = document.getElementById('headerName');
    const quadrasInput = document.getElementById('quadras');
    const quadrasInfoSpan = document.getElementById('quadrasInfo');
    const infoPopup = document.getElementById('infoPopup');
    const popupTitle = document.getElementById('popupTitle');
    const popupMessage = document.getElementById('popupMessage');
    const popupClose = document.querySelector('.popup-close');
    const btnSortear = document.getElementById('btnSortear');
    const btnReiniciar = document.getElementById('btnReiniciar');
    const championInfoDiv = document.getElementById('championInfoDiv'); // Novo div para info do campeão
    const sortResultInfo = document.getElementById('sortResultInfo'); // Novo div para info do sorteio

    // Estado global da aplicação
    let generatedGames = [];
    let currentMode = 'individual-sem-pote';
    let fixedDuosMap = {};

    // Constantes para chaves do localStorage
    const LOCAL_STORAGE_KEY_GAMES = 'super8_generatedGames';
    const LOCAL_STORAGE_KEY_CONFIG = 'super8_config';
    const LOCAL_STORAGE_KEY_MODE_LOCKED = 'super8_modeLocked';
    const LOCAL_STORAGE_KEY_FIXED_DUOS = 'super8_fixedDuos';

    // Event listener para mudança de modo de jogo
    radiosModo.forEach(radio => radio.addEventListener('change', () => {
        currentMode = radio.value;
        if (currentMode.includes('com-pote')) {
            campoComPote.style.display = 'block';
            campoSemPote.style.display = 'none';
        } else {
            campoComPote.style.display = 'none';
            campoSemPote.style.display = 'block';
        }
        poteOptionsDiv.style.display = 'none';
        playerActionInfoDiv.style.display = 'none';
        updateQuadrasInputLimits();
    }));

    // Event listener para input de jogadores/potes para atualizar limites de quadra
    jogadoresTextArea.addEventListener('input', updateQuadrasInputLimits);
    pote1TextArea.addEventListener('input', updateQuadrasInputLimits);
    pote2TextArea.addEventListener('input', updateQuadrasInputLimits);

    // Event listener para fechar o pop-up
    popupClose.addEventListener('click', () => {
        infoPopup.style.display = 'none';
    });
    window.addEventListener('click', (event) => {
        if (event.target == infoPopup) {
            infoPopup.style.display = 'none';
        }
    });

    /**
     * Exibe o pop-up com um título e mensagem.
     * @param {string} title - O título do pop-up.
     * @param {string} message - A mensagem a ser exibida no pop-up.
     */
    function showPopup(title, message) {
        popupTitle.textContent = title;
        popupMessage.innerHTML = message;
        infoPopup.style.display = 'block';
    }

    /**
     * Salva o estado atual do jogo no localStorage.
     */
    function saveGameState() {
        const config = {
            mode: currentMode,
            jogadores: jogadoresTextArea.value,
            pote1: pote1TextArea.value,
            pote2: pote2TextArea.value,
            quadras: quadrasInput.value
        };
        localStorage.setItem(LOCAL_STORAGE_KEY_GAMES, JSON.stringify(generatedGames));
        localStorage.setItem(LOCAL_STORAGE_KEY_CONFIG, JSON.stringify(config));
        localStorage.setItem(LOCAL_STORAGE_KEY_FIXED_DUOS, JSON.stringify(fixedDuosMap));

        if (generatedGames.length > 0) {
            localStorage.setItem(LOCAL_STORAGE_KEY_MODE_LOCKED, 'true');
        } else {
            localStorage.removeItem(LOCAL_STORAGE_KEY_MODE_LOCKED);
        }
    }

    /**
     * Carrega o estado do jogo do localStorage.
     */
    function loadGameState() {
        const savedGames = localStorage.getItem(LOCAL_STORAGE_KEY_GAMES);
        const savedConfig = localStorage.getItem(LOCAL_STORAGE_KEY_CONFIG);
        const modeLocked = localStorage.getItem(LOCAL_STORAGE_KEY_MODE_LOCKED) === 'true';
        const savedFixedDuos = localStorage.getItem(LOCAL_STORAGE_KEY_FIXED_DUOS);

        if (savedConfig) {
            const config = JSON.parse(savedConfig);
            currentMode = config.mode;
            
            document.querySelector(`input[name="modo"][value="${currentMode}"]`).checked = true;

            if (currentMode.includes('com-pote')) {
                campoComPote.style.display = 'block';
                campoSemPote.style.display = 'none';
            } else {
                campoComPote.style.display = 'none';
                campoSemPote.style.display = 'block';
            }

            // Set text area values without generic names
            jogadoresTextArea.value = config.jogadores || '';
            pote1TextArea.value = config.pote1 || '';
            pote2TextArea.value = config.pote2 || '';
            quadrasInput.value = config.quadras || 1;
        } else {
            resetApplicationState(false); 
        }

        if (savedFixedDuos) {
            fixedDuosMap = JSON.parse(savedFixedDuos);
        }

        if (savedGames) {
            generatedGames = JSON.parse(savedGames);
            displayGames(generatedGames);
            updateClassification();
            tabButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector('button[data-tab="jogos"]').classList.add('active');
            sections.forEach(sec => {
                if (sec.id === 'jogos') sec.classList.add('active');
                else sec.classList.remove('active');
            });
            setConfigurationFieldsDisabled(true); 
            radiosModo.forEach(radio => radio.disabled = modeLocked);
            sortResultInfo.textContent = 'Os jogos foram criados com sucesso!'; // Restore success message

        } else {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector('button[data-tab="config"]').classList.add('active');
            sections.forEach(sec => {
                if (sec.id === 'config') sec.classList.add('active');
                else sec.classList.remove('active');
            });
            setConfigurationFieldsDisabled(false);
            radiosModo.forEach(radio => radio.disabled = false);
            sortResultInfo.textContent = ''; // Clear message if no games are loaded
        }
        updateQuadrasInputLimits(); 
    }

    /**
     * Embaralha um array (Fisher-Yates shuffle).
     * @param {Array} array - O array a ser embaralhado.
     */
    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    /**
     * Normaliza a entrada de texto de jogadores/potes para um array limpo de strings.
     * Remove espaços em branco extras e linhas vazias.
     * @param {string} text - O texto de entrada do textarea.
     * @returns {Array<string>} Um array de nomes de jogadores.
     */
    function parsePlayerInput(text) {
        return text.split('\n')
                    .map(player => player.trim())
                    .filter(player => player !== '');
    }

    /**
     * Calcula o número máximo de quadras com base no número de jogadores.
     * 1 quadra para cada 4 jogadores (ou 2 duplas), arredondado para baixo.
     * @param {number} numPlayers - O número total de jogadores.
     * @param {string} mode - O modo de jogo ('individual' ou 'dupla').
     * @returns {number} O número máximo de quadras.
     */
    function calculateMaxQuadras(numPlayers, mode) {
        if (mode === 'dupla') {
            return Math.floor(numPlayers / 2);
        } else {
            return Math.floor(numPlayers / 4);
        }
    }

    /**
     * Atualiza os limites (min/max) do input de quadras e exibe uma mensagem.
     */
    function updateQuadrasInputLimits() {
        let playersCount = 0;
        let modeForCalculation = 'individual'; 

        if (currentMode.includes('com-pote')) {
            const pote1 = parsePlayerInput(pote1TextArea.value);
            const pote2 = parsePlayerInput(pote2TextArea.value);
            
            if (currentMode.startsWith('dupla-fixa')) {
                modeForCalculation = 'dupla';
                // Para duplas fixas com pote, o número de "duplas" é o tamanho do menor pote.
                // Cada dupla ocupa 2 "slots" em uma partida de 4 pessoas.
                // Então, o número de "players" para cálculo do maxQuadras é o dobro do número de duplas.
                playersCount = Math.min(pote1.length, pote2.length) * 2; 
            } else {
                playersCount = pote1.length + pote2.length;
            }
        } else {
            const players = parsePlayerInput(jogadoresTextArea.value);
            playersCount = players.length;
            if (currentMode.startsWith('dupla-fixa')) {
                modeForCalculation = 'dupla';
                playersCount = Math.ceil(players.length / 2) * 2; // Representa o número de "jogadores" se fossem duplas fixas
            }
        }
        
        const maxQuadras = calculateMaxQuadras(playersCount, modeForCalculation);
        
        quadrasInput.min = 1;
        quadrasInput.max = Math.max(1, maxQuadras); 

        quadrasInfoSpan.textContent = `(Máximo ${quadrasInput.max} quadra${quadrasInput.max > 1 ? 's' : ''})`;

        if (parseInt(quadrasInput.value) > quadrasInput.max) {
            quadrasInput.value = quadrasInput.max;
        }
    }

    /**
     * Habilita ou desabilita os campos de configuração.
     * @param {boolean} disabled - True para desabilitar, False para habilitar.
     */
    function setConfigurationFieldsDisabled(disabled) {
        jogadoresTextArea.disabled = disabled;
        pote1TextArea.disabled = disabled;
        pote2TextArea.disabled = disabled;
        quadrasInput.disabled = disabled;
        btnSortear.disabled = disabled;
        
        if (disabled) {
            poteOptionsDiv.style.display = 'none';
        }
    }

    // --- Funções de Geração de Jogos ---

    /**
     * Gera todos os jogos possíveis para o modo "Individual sem Pote" usando Round-Robin
     * e os distribui sequencialmente pelas quadras disponíveis.
     * Garante que todos os jogos sejam gerados, independentemente do número de quadras,
     * e os atribui a rodadas e quadras de forma sequential.
     * @param {Array<string>} players - Lista de nomes dos jogadores.
     * @returns {Array<Object>} Lista de jogos gerados com rodada e quadra atribuídas.
     */
    function generateGamesIndividualNoPot(players) {
        let allPlayers = [...players];
        const n = allPlayers.length;

        if (n < 4) {
            alert("Para o modo 'Individual sem pote', você precisa de pelo menos 4 jogadores para formar duplas.");
            return [];
        }

        let tempPlayers = [...allPlayers];
        let effectiveN = n;
        
        if (effectiveN % 2 !== 0) {
            tempPlayers.push('Livre');
            effectiveN++;
        }

        const numRoundsTheoretical = effectiveN - 1;
        let allPotentialGames = [];

        for (let r = 0; r < numRoundsTheoretical; r++) {
            let roundDuos = [];
            const fixedPlayer = tempPlayers[0];
            const rotatingPlayers = tempPlayers.slice(1);

            for (let i = 0; i < effectiveN / 2; i++) {
                let p1, p2;
                if (i === 0) {
                    p1 = fixedPlayer;
                    p2 = rotatingPlayers[rotatingPlayers.length - 1 - i];
                } else {
                    p1 = rotatingPlayers[i - 1];
                    p2 = rotatingPlayers[rotatingPlayers.length - 1 - i];
                }
                roundDuos.push([p1, p2]);
            }
            
            shuffle(roundDuos);

            const playableDuos = roundDuos.filter(duo => !duo.includes('Livre'));
            for (let i = 0; i < playableDuos.length; i += 2) {
                if (i + 1 < playableDuos.length) {
                    allPotentialGames.push({
                        duplaA: playableDuos[i],
                        duplaB: playableDuos[i + 1],
                        gamesDuplaA: 0, // Inicializa com 0
                        gamesDuplaB: 0  // Inicializa com 0
                    });
                }
            }

            const lastPlayer = rotatingPlayers.pop();
            rotatingPlayers.unshift(lastPlayer);
            tempPlayers = [fixedPlayer, ...rotatingPlayers];
        }

        let finalGames = [];
        const numQuadras = parseInt(quadrasInput.value);
        let currentRound = 1;
        let currentQuadra = 1;

        allPotentialGames.forEach(game => {
            finalGames.push({
                ...game,
                rodada: currentRound,
                quadra: currentQuadra
            });

            currentQuadra++;
            if (currentQuadra > numQuadras) {
                currentQuadra = 1;
                currentRound++;
            }
        });
        
        return finalGames;
    }

    /**
     * Gera jogos para o modo "Individual com Pote", garantindo que cada dupla PoteA-PoteB
     * seja única ao longo de todo o torneio, e que cada jogo tenha 4 jogadores únicos.
     * Tenta encontrar uma solução que balanceie os jogos entre os jogadores, priorizando quem jogou menos recentemente.
     * Prioriza a variação nas duplas adversárias.
     * @param {Array<string>} pote1 - Jogadores do Pote 1.
     * @param {Array<string>} pote2 - Jogadores do Pote 2.
     * @returns {Array<Object>} Lista de jogos gerados.
     */
    function generateGamesIndividualWithPot(pote1, pote2) {
        const numPote1 = pote1.length;
        const numPote2 = pote2.length;
        const numQuadras = parseInt(quadrasInput.value);

        if (numPote1 < 2 || numPote2 < 2) {
            alert("Para o modo 'Individual com pote', você precisa de pelo menos 2 jogadores em cada pote para formar jogos válidos (dupla contra dupla).");
            return [];
        }

        let allPlayers = [...pote1, ...pote2];
        let lastPlayedRound = {};
        allPlayers.forEach(p => (lastPlayedRound[p] = -1));
        
        let allPossibleP1P2Duos = [];
        pote1.forEach(pA => {
            pote2.forEach(pB => {
                allPossibleP1P2Duos.push([pA, pB]);
            });
        });
        
        let finalGames = [];
        let usedP1P2DuosInTournament = new Set();
        let usedPlayerPairsAsOpponents = new Set();

        const arePlayersUnique = (pA1, pB1, pA2, pB2) => {
            return new Set([pA1, pB1, pA2, pB2]).size === 4;
        };

        const haveDuosPlayedBefore = (duo1, duo2) => {
            const players = [...duo1, ...duo2].sort();
            return usedPlayerPairsAsOpponents.has(players.join('|'));
        };

        const markDuosAsOpponents = (duo1, duo2) => {
            const players = [...duo1, ...duo2].sort();
            usedPlayerPairsAsOpponents.add(players.join('|'));
        };

        let rodadaCounter = 1;
        
        let allGeneratedGames = [];

        let safetyBreak = 0;
        const MAX_ITERATIONS = 500;

        while (safetyBreak < MAX_ITERATIONS) {
            let gamesThisRoundAttempt = [];
            let playersUsedInCurrentAttempt = new Set(); 
            let availableP1P2Duos = allPossibleP1P2Duos.filter(duo => !usedP1P2DuosInTournament.has(duo.join('|')));
            
            shuffle(availableP1P2Duos);

            availableP1P2Duos.sort((duo1, duo2) => {
                const lp1_1 = lastPlayedRound[duo1[0]];
                const lp1_2 = lastPlayedRound[duo1[1]];
                const lp2_1 = lastPlayedRound[duo2[0]];
                const lp2_2 = lastPlayedRound[duo2[1]];

                const inactivitySum1 = (rodadaCounter - lp1_1) + (rodadaCounter - lp1_2);
                const inactivitySum2 = (rodadaCounter - lp2_1) + (rodadaCounter - lp2_2);

                return inactivitySum2 - inactivitySum1;
            });


            for (let i = 0; i < availableP1P2Duos.length; i++) {
                const teamA = availableP1P2Duos[i];
                if (playersUsedInCurrentAttempt.has(teamA[0]) || playersUsedInCurrentAttempt.has(teamA[1])) {
                    continue;
                }

                for (let j = i + 1; j < availableP1P2Duos.length; j++) {
                    const teamB = availableP1P2Duos[j];
                    if (playersUsedInCurrentAttempt.has(teamB[0]) || playersUsedInCurrentAttempt.has(teamB[1])) {
                        continue;
                    }

                    if (!arePlayersUnique(teamA[0], teamA[1], teamB[0], teamB[1])) {
                        continue;
                    }
                    
                    if (haveDuosPlayedBefore(teamA, teamB)) {
                        continue;
                    }

                    gamesThisRoundAttempt.push({ 
                        duplaA: teamA, 
                        duplaB: teamB,
                        gamesDuplaA: 0, // Inicializa com 0
                        gamesDuplaB: 0  // Inicializa com 0
                    });
                    
                    playersUsedInCurrentAttempt.add(teamA[0]);
                    playersUsedInCurrentAttempt.add(teamA[1]);
                    playersUsedInCurrentAttempt.add(teamB[0]);
                    playersUsedInCurrentAttempt.add(teamB[1]);

                    usedP1P2DuosInTournament.add(teamA.join('|'));
                    usedP1P2DuosInTournament.add(teamB.join('|'));
                    markDuosAsOpponents(teamA, teamB); 
                    
                    if (gamesThisRoundAttempt.length >= numQuadras) {
                        break; 
                    }
                }
                if (gamesThisRoundAttempt.length >= numQuadras) {
                    break;
                }
            }
            
            if (gamesThisRoundAttempt.length === 0) {
                break; 
            }

            allGeneratedGames.push(...gamesThisRoundAttempt);

            playersUsedInCurrentAttempt.forEach(player => {
                lastPlayedRound[player] = rodadaCounter;
            });

            rodadaCounter++;
            safetyBreak++;
        }
        
        let currentAssignedRound = 1;
        let currentAssignedQuadra = 1;
        allGeneratedGames.forEach(game => {
            finalGames.push({
                ...game,
                rodada: currentAssignedRound,
                quadra: currentAssignedQuadra
            });
            currentAssignedQuadra++;
            if (currentAssignedQuadra > numQuadras) {
                currentAssignedQuadra = 1;
                currentAssignedRound++;
            }
        });

        return finalGames;
    }


    /**
     * Gera duplas fixas a partir de uma lista de jogadores.
     * Se houver um número ímpar de jogadores, o último jogador é pareado com 'Livre'.
     * Armazena as duplas geradas em fixedDuosMap para uso na classificação.
     * @param {Array<string>} players - Lista de nomes dos jogadores.
     * @returns {Array<Array<string>>} Lista de duplas fixas.
     */
    function generateFixedDuos(players) {
        const shuffledPlayers = [...players];
        shuffle(shuffledPlayers);
        let duos = [];
        fixedDuosMap = {}; // Resetar fixedDuosMap a cada geração para evitar lixo de estado anterior
        for (let i = 0; i < shuffledPlayers.length; i += 2) {
            let duo;
            if (i + 1 < shuffledPlayers.length) {
                duo = [shuffledPlayers[i], shuffledPlayers[i + 1]].sort();
            } else {
                duo = [shuffledPlayers[i], 'Livre'].sort();
            }
            duos.push(duo);
            fixedDuosMap[duo.join(' & ')] = duo.join(' & '); // Armazena a dupla normalizada como chave e valor
        }
        return duos;
    }

    /**
     * Gera jogos para o modo "Dupla Fixa sem Pote" usando Round-Robin
     * e os distribui sequencialmente pelas quadras disponíveis.
     * @param {Array<string>} players - Lista de nomes dos jogadores para formar duplas.
     * @returns {Array<Object>} Lista de jogos gerados com rodada e quadra atribuída.
     */
    function generateGamesFixedDuoNoPot(players) {
        const fixedDuos = generateFixedDuos(players);
        let allPotentialGames = [];
        const numQuadras = parseInt(quadrasInput.value);

        let tempDuos = [...fixedDuos];
        if (tempDuos.length < 2) {
            alert("Para o modo 'Dupla fixa sem pote', você precisa de pelo menos 2 duplas para formar um jogo.");
            return [];
        }
        if (tempDuos.length % 2 !== 0) {
            tempDuos.push(['Livre', 'Livre']); // Adiciona uma dupla "Livre" para garantir um número par de duplas
        }
        
        const numDuplas = tempDuos.length;
        const numRoundsTheoretical = numDuplas - 1;

        for (let r = 0; r < numRoundsTheoretical; r++) {
            let roundMatches = [];
            const fixedDuo = tempDuos[0];
            const rotatingDuos = tempDuos.slice(1);

            for (let i = 0; i < numDuplas / 2; i++) {
                let duo1, duo2;
                if (i === 0) {
                    duo1 = fixedDuo;
                    duo2 = rotatingDuos[rotatingDuos.length - 1 - i];
                } else {
                    duo1 = rotatingDuos[i - 1];
                    duo2 = rotatingDuos[rotatingDuos.length - 1 - i];
                }
                roundMatches.push({ duoA: duo1, duoB: duo2 });
            }
            shuffle(roundMatches);

            roundMatches.forEach(match => {
                if (!match.duoA.includes('Livre') && !match.duoB.includes('Livre')) {
                    allPotentialGames.push({
                        duplaA: match.duoA,
                        duplaB: match.duoB,
                        gamesDuplaA: 0,
                        gamesDuplaB: 0
                    });
                }
            });

            const lastDuo = rotatingDuos.pop();
            rotatingDuos.unshift(lastDuo);
            tempDuos = [fixedDuo, ...rotatingDuos];
        }

        let finalGames = [];
        let currentRound = 1;
        let currentQuadra = 1;

        allPotentialGames.forEach(game => {
            finalGames.push({
                ...game,
                rodada: currentRound,
                quadra: currentQuadra
            });

            currentQuadra++;
            if (currentQuadra > numQuadras) {
                currentQuadra = 1;
                currentRound++;
            }
        });

        return finalGames;
    }

    /**
     * Gera jogos para o modo "Dupla Fixa com Pote".
     * Cria duplas fixas misturando jogadores dos potes e então gera jogos entre essas duplas.
     * @param {Array<string>} pote1 - Jogadores do Pote 1.
     * @param {Array<string>} pote2 - Jogadores do Pote 2.
     * @returns {Array<Object>} Lista de jogos gerados.
     */
    function generateGamesFixedDuoWithPot(pote1, pote2) {
        const numQuadras = parseInt(quadrasInput.value);

        if (pote1.length === 0 || pote2.length === 0) {
            alert("Para o modo 'Dupla fixa com pote', ambos os potes devem ter jogadores.");
            return [];
        }

        // Embaralha os potes para formar duplas de forma justa
        let shuffledPote1 = [...pote1];
        shuffle(shuffledPote1);
        let shuffledPote2 = [...pote2];
        shuffle(shuffledPote2);

        // Garante que ambos os potes tenham o mesmo número de jogadores, ajustando se necessário
        // Se um pote é maior, remove jogadores aleatoriamente do maior para igualar.
        if (shuffledPote1.length !== shuffledPote2.length) {
            showPopup('Atenção', 'Os potes têm números de jogadores diferentes. Por favor, ajuste-os para ter o mesmo número ou use as opções abaixo.');
            poteOptionsDiv.style.display = 'block';
            
            const diff = Math.abs(shuffledPote1.length - shuffledPote2.length);
            let message = '';
            if (shuffledPote1.length > shuffledPote2.length) {
                message = `Pote 1 (${shuffledPote1.length} jogadores) é maior que Pote 2 (${shuffledPote2.length} jogadores).`;
                playerActionInfoDiv.innerHTML = `Serão excluídos ${diff} jogador(es) do Pote 1.`;
                btnMovePlayer.style.display = 'none';
            } else {
                message = `Pote 2 (${shuffledPote2.length} jogadores) é maior que Pote 1 (${shuffledPote1.length} jogadores).`;
                playerActionInfoDiv.innerHTML = `Serão excluídos ${diff} jogador(es) do Pote 2.`;
                btnMovePlayer.style.display = 'none';
            }
            playerActionInfoDiv.style.display = 'block';
            return [];
        }

        fixedDuosMap = {};
        let fixedDuos = [];
        for (let i = 0; i < shuffledPote1.length; i++) {
            const duo = [shuffledPote1[i], shuffledPote2[i]].sort();
            fixedDuos.push(duo);
            fixedDuosMap[duo.join(' & ')] = duo.join(' & ');
        }
        
        // Aplica o algoritmo Round-Robin para as duplas fixas
        let allPotentialGames = [];
        let tempDuos = [...fixedDuos];
        if (tempDuos.length % 2 !== 0) {
            tempDuos.push(['Livre', 'Livre']);
        }
        const numDuplas = tempDuos.length;
        const numRoundsTheoretical = numDuplas - 1;

        for (let r = 0; r < numRoundsTheoretical; r++) {
            let roundMatches = [];
            const fixedDuo = tempDuos[0];
            const rotatingDuos = tempDuos.slice(1);

            for (let i = 0; i < numDuplas / 2; i++) {
                let duo1, duo2;
                if (i === 0) {
                    duo1 = fixedDuo;
                    duo2 = rotatingDuos[rotatingDuos.length - 1 - i];
                } else {
                    duo1 = rotatingDuos[i - 1];
                    duo2 = rotatingDuos[rotatingDuos.length - 1 - i];
                }
                roundMatches.push({ duoA: duo1, duoB: duo2 });
            }
            shuffle(roundMatches);

            roundMatches.forEach(match => {
                if (!match.duoA.includes('Livre') && !match.duoB.includes('Livre')) {
                    allPotentialGames.push({
                        duplaA: match.duoA,
                        duplaB: match.duoB,
                        gamesDuplaA: 0,
                        gamesDuplaB: 0
                    });
                }
            });

            const lastDuo = rotatingDuos.pop();
            rotatingDuos.unshift(lastDuo);
            tempDuos = [fixedDuo, ...rotatingDuos];
        }

        let finalGames = [];
        let currentRound = 1;
        let currentQuadra = 1;

        allPotentialGames.forEach(game => {
            finalGames.push({
                ...game,
                rodada: currentRound,
                quadra: currentQuadra
            });

            currentQuadra++;
            if (currentQuadra > numQuadras) {
                currentQuadra = 1;
                currentRound++;
            }
        });

        return finalGames;
    }

    // Ações para potes com tamanhos diferentes
    document.getElementById('btnExcludePlayer').addEventListener('click', () => {
        let pote1 = parsePlayerInput(pote1TextArea.value);
        let pote2 = parsePlayerInput(pote2TextArea.value);

        if (pote1.length > pote2.length) {
            // Remove aleatoriamente do pote 1
            const numToRemove = pote1.length - pote2.length;
            for (let i = 0; i < numToRemove; i++) {
                pote1.splice(Math.floor(Math.random() * pote1.length), 1);
            }
            pote1TextArea.value = pote1.join('\n');
        } else if (pote2.length > pote1.length) {
            // Remove aleatoriamente do pote 2
            const numToRemove = pote2.length - pote1.length;
            for (let i = 0; i < numToRemove; i++) {
                pote2.splice(Math.floor(Math.random() * pote2.length), 1);
            }
            pote2TextArea.value = pote2.join('\n');
        }
        playerActionInfoDiv.style.display = 'none';
        poteOptionsDiv.style.display = 'none';
        updateQuadrasInputLimits();
        showPopup('Ação Concluída', 'Jogadores foram excluídos para igualar o número de participantes nos potes.');
    });

    /**
     * Manipula o sorteio de jogos com base no modo selecionado.
     */
    function handleSortGames() {
        const numQuadras = parseInt(quadrasInput.value);
        if (isNaN(numQuadras) || numQuadras < 1) {
            showPopup('Erro', 'Por favor, insira um número válido de quadras (mínimo 1).');
            return;
        }

        let playersOrPotsValid = false;
        if (currentMode.includes('com-pote')) {
            const pote1 = parsePlayerInput(pote1TextArea.value);
            const pote2 = parsePlayerInput(pote2TextArea.value);
            if (pote1.length === 0 || pote2.length === 0) {
                showPopup('Erro', 'Por favor, preencha ambos os potes com jogadores.');
                return;
            }
            if (currentMode.startsWith('dupla-fixa') && pote1.length !== pote2.length) {
                // Mensagem de erro específica já é tratada dentro de generateGamesFixedDuoWithPot
                return; 
            }
            playersOrPotsValid = true;
        } else {
            const players = parsePlayerInput(jogadoresTextArea.value);
            if (players.length === 0) {
                showPopup('Erro', 'Por favor, insira os nomes dos jogadores.');
                return;
            }
            playersOrPotsValid = true;
        }

        if (!playersOrPotsValid) return;

        let games = [];
        if (currentMode === 'individual-sem-pote') {
            const players = parsePlayerInput(jogadoresTextArea.value);
            games = generateGamesIndividualNoPot(players);
        } else if (currentMode === 'individual-com-pote') {
            const pote1 = parsePlayerInput(pote1TextArea.value);
            const pote2 = parsePlayerInput(pote2TextArea.value);
            games = generateGamesIndividualWithPot(pote1, pote2);
        } else if (currentMode === 'dupla-fixa-sem-pote') {
            const players = parsePlayerInput(jogadoresTextArea.value);
            games = generateGamesFixedDuoNoPot(players);
        } else if (currentMode === 'dupla-fixa-com-pote') {
            const pote1 = parsePlayerInput(pote1TextArea.value);
            const pote2 = parsePlayerInput(pote2TextArea.value);
            games = generateGamesFixedDuoWithPot(pote1, pote2);
        }

        if (games.length === 0) {
            alert("Não foi possível gerar jogos com as configurações atuais. Verifique o número de jogadores e o modo de jogo.");
            return;
        }
        
        generatedGames = games; // Update global state
        displayGames(generatedGames);
        updateClassification(); // Não mostra pop-up de campeão no sorteio inicial
        saveGameState();
        setConfigurationFieldsDisabled(true);
        // Trava os radios de modo após o sorteio
        radiosModo.forEach(radio => radio.disabled = true);
        
        showPopup('Sorteio Realizado!', 'Os jogos foram criados com sucesso.'); // Pop-up de sorteio
    }

    // --- Associações de Eventos ---
    document.getElementById('btnSortear').addEventListener('click', handleSortGames);

    document.getElementById('btnReiniciar').addEventListener('click', () => {
        if (confirm('Tem certeza que deseja reiniciar e apagar todas as informações?')) {
            resetApplicationState(true);
            tabButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector('button[data-tab="config"]').classList.add('active');
            sections.forEach(sec => {
                if (sec.id === 'config') sec.classList.add('active');
                else sec.classList.remove('active');
            });
        }
    });

    // Carrega o estado do jogo ao carregar a página
    window.addEventListener('load', loadGameState);

    /**
     * Exibe os jogos na tabela de jogos.
     * @param {Array<Object>} games - Lista de jogos a serem exibidos.
     */
    function displayGames(games) {
        tabelaJogosBody.innerHTML = ''; // Limpa a tabela
        games.forEach((game, index) => {
            const row = tabelaJogosBody.insertRow();
            row.dataset.gameIndex = index; // Guarda o índice do jogo
            row.insertCell(0).textContent = game.rodada;
            row.insertCell(1).textContent = game.quadra;
            row.insertCell(2).textContent = game.duplaA.join(' / ');
            const scoreCell = row.insertCell(3);
            scoreCell.innerHTML = `
                <input type="number" class="result-input" min="0" value="${game.gamesDuplaA}" data-player="A">
                x
                <input type="number" class="result-input" min="0" value="${game.gamesDuplaB}" data-player="B">
            `;
            scoreCell.querySelectorAll('.result-input').forEach(input => {
                input.addEventListener('change', (e) => {
                    const gameIndex = parseInt(e.target.closest('tr').dataset.gameIndex);
                    if (e.target.dataset.player === 'A') {
                        generatedGames[gameIndex].gamesDuplaA = parseInt(e.target.value) || 0;
                    } else {
                        generatedGames[gameIndex].gamesDuplaB = parseInt(e.target.value) || 0;
                    }
                    saveGameState();
                    updateClassification(); // Atualiza a classificação ao mudar o resultado
                });
            });
            row.insertCell(4).textContent = game.duplaB.join(' / ');
        });
    }

    /**
     * Reinicia o estado da aplicação, limpando dados do localStorage e redefinindo UI.
     * @param {boolean} confirmReset - Se true, exibe o pop-up de confirmação de reinício.
     */
    function resetApplicationState(confirmReset) {
        if (confirmReset) {
            localStorage.removeItem(LOCAL_STORAGE_KEY_GAMES);
            localStorage.removeItem(LOCAL_STORAGE_KEY_CONFIG);
            localStorage.removeItem(LOCAL_STORAGE_KEY_MODE_LOCKED);
            localStorage.removeItem(LOCAL_STORAGE_KEY_FIXED_DUOS);
            generatedGames = [];
            fixedDuosMap = {};
        }

        radiosModo.forEach(radio => radio.disabled = false);
        document.querySelector('input[name="modo"][value="individual-sem-pote"]').checked = true;
        currentMode = 'individual-sem-pote';
        campoComPote.style.display = 'none';
        campoSemPote.style.display = 'block';

        jogadoresTextArea.value = '';
        pote1TextArea.value = '';
        pote2TextArea.value = '';
        quadrasInput.value = 1;
        
        tabelaJogosBody.innerHTML = '';
        tabelaResultadoBody.innerHTML = '';
        championInfoDiv.textContent = ''; // Limpa a informação do campeão
        sortResultInfo.textContent = ''; // Limpa a mensagem de sorteio

        setConfigurationFieldsDisabled(false);
        updateQuadrasInputLimits(); // Reset limits
    }


    /**
     * Atualiza a tabela de classificação com base nos resultados dos jogos.
     */
    function updateClassification() {
        tabelaResultadoBody.innerHTML = '';
        const playerStats = {}; // Map para armazenar estatísticas por jogador ou dupla

        const isFixedDuoMode = currentMode.startsWith('dupla-fixa');

        // Inicializa estatísticas para todos os jogadores ou duplas
        if (isFixedDuoMode) {
            let allPlayers = [];
            if (currentMode.includes('com-pote')) {
                allPlayers = [...parsePlayerInput(pote1TextArea.value), ...parsePlayerInput(pote2TextArea.value)];
            } else {
                allPlayers = parsePlayerInput(jogadoresTextArea.value);
            }
            generateFixedDuos(allPlayers).forEach(duo => {
                const duoName = duo.join(' & ');
                playerStats[duoName] = { wins: 0, losses: 0, gamesWon: 0, gamesLost: 0, duoPlayers: duo };
            });
            headerName.textContent = 'Dupla';
        } else {
            const allPlayers = currentMode.includes('com-pote')
                ? [...parsePlayerInput(pote1TextArea.value), ...parsePlayerInput(pote2TextArea.value)]
                : parsePlayerInput(jogadoresTextArea.value);
            
            allPlayers.forEach(player => {
                playerStats[player] = { wins: 0, losses: 0, gamesWon: 0, gamesLost: 0 };
            });
            headerName.textContent = 'Jogador';
        }

        // Processa os resultados dos jogos
        generatedGames.forEach(game => {
            const scoreA = parseInt(game.gamesDuplaA) || 0;
            const scoreB = parseInt(game.gamesDuplaB) || 0;

            const teamAName = isFixedDuoMode ? game.duplaA.join(' & ') : game.duplaA;
            const teamBName = isFixedDuoMode ? game.duplaB.join(' & ') : game.duplaB;

            if (isFixedDuoMode) {
                // Ensure the duo names are in the map, potentially created by generateFixedDuos
                if (!playerStats[teamAName]) {
                    playerStats[teamAName] = { wins: 0, losses: 0, gamesWon: 0, gamesLost: 0, duoPlayers: game.duplaA };
                }
                if (!playerStats[teamBName]) {
                    playerStats[teamBName] = { wins: 0, losses: 0, gamesWon: 0, gamesLost: 0, duoPlayers: game.duplaB };
                }
            } else {
                // Individual players
                game.duplaA.forEach(player => {
                    if (!playerStats[player]) playerStats[player] = { wins: 0, losses: 0, gamesWon: 0, gamesLost: 0 };
                });
                game.duplaB.forEach(player => {
                    if (!playerStats[player]) playerStats[player] = { wins: 0, losses: 0, gamesWon: 0, gamesLost: 0 };
                });
            }

            if (scoreA > scoreB) {
                if (isFixedDuoMode) {
                    playerStats[teamAName].wins++;
                    playerStats[teamBName].losses++;
                } else {
                    game.duplaA.forEach(player => playerStats[player].wins++);
                    game.duplaB.forEach(player => playerStats[player].losses++);
                }
            } else if (scoreB > scoreA) {
                if (isFixedDuoMode) {
                    playerStats[teamBName].wins++;
                    playerStats[teamAName].losses++;
                } else {
                    game.duplaB.forEach(player => playerStats[player].wins++);
                    game.duplaA.forEach(player => playerStats[player].losses++);
                }
            }

            if (isFixedDuoMode) {
                playerStats[teamAName].gamesWon += scoreA;
                playerStats[teamAName].gamesLost += scoreB;
                playerStats[teamBName].gamesWon += scoreB;
                playerStats[teamBName].gamesLost += scoreA;
            } else {
                game.duplaA.forEach(player => {
                    playerStats[player].gamesWon += scoreA;
                    playerStats[player].gamesLost += scoreB;
                });
                game.duplaB.forEach(player => {
                    playerStats[player].gamesWon += scoreB;
                    playerStats[player].gamesLost += scoreA;
                });
            }
        });

        // Converte o mapa em um array e ordena
        let classification = Object.keys(playerStats).map(name => {
            const stats = playerStats[name];
            return {
                name: name,
                wins: stats.wins,
                losses: stats.losses,
                gamesWon: stats.gamesWon,
                gamesLost: stats.gamesLost,
                gameBalance: stats.gamesWon - stats.gamesLost
            };
        });

        classification.sort((a, b) => {
            if (a.wins !== b.wins) {
                return b.wins - a.wins; // Mais vitórias primeiro
            }
            if (a.gameBalance !== b.gameBalance) {
                return b.gameBalance - a.gameBalance; // Maior saldo de games
            }
            // Critério de desempate por confronto direto (requer lógica mais complexa, omitida para simplicidade neste exemplo)
            return 0;
        });

        // Exibe a classificação na tabela
        classification.forEach((data, index) => {
            const row = tabelaResultadoBody.insertRow();
            row.insertCell(0).textContent = index + 1;
            row.insertCell(1).textContent = data.name;
            row.insertCell(2).textContent = data.wins;
            row.insertCell(3).textContent = data.losses;
            row.insertCell(4).textContent = data.gameBalance;
            row.insertCell(5).textContent = data.gamesWon;
            row.insertCell(6).textContent = data.gamesLost;
        });

        // Exibir Campeão se houver jogos e pelo menos um resultado
        if (generatedGames.length > 0 && classification.length > 0) {
            const topPlayer = classification[0];
            // Verifica se há mais de um campeão (empate na primeira posição)
            const champions = classification.filter(player => 
                player.wins === topPlayer.wins && 
                player.gameBalance === topPlayer.gameBalance
            );

            if (champions.length === 1) {
                championInfoDiv.textContent = `🏆 Campeão: ${topPlayer.name} com ${topPlayer.wins} vitórias!`;
                // showPopup('Parabéns!', `O campeão é ${topPlayer.name} com ${topPlayer.wins} vitórias e saldo de games de ${topPlayer.gameBalance}!`);
            } else {
                const championNames = champions.map(c => c.name).join(', ');
                championInfoDiv.textContent = `🏆 Empate na liderança: ${championNames} com ${topPlayer.wins} vitórias!`;
                // showPopup('Parabéns!', `Empate na liderança entre ${championNames} com ${topPlayer.wins} vitórias e saldo de games de ${topPlayer.gameBalance}!`);
            }
        } else {
            championInfoDiv.textContent = ''; // Limpa a informação do campeão se não houver jogos ou resultados
        }
    }

</script>
</body>
</html>
